<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LoadVUE Pro Cloud</title>
<meta name="Description" content="Set your baud speed and hit connect. A serial terminal that runs without any plugins in chrome.">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    * {
        background-color: #ECECEC;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        padding: 0px;
    }
    .horizontal-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 75%;
        color: #000000;
        margin-top: 10px;
    }
    .Header_Title{
        text-align: left;
        background-color: #B2E4FF;
        font-size: xx-large;
    }
    .right {
        text-align: right;
        background-color: #B2E4FF;
    }
    .container2 {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
    }
    .button {
        width: 25%;
        height: 25px; 
        color: #FFFFFF;
    }
    .subheading {
        font-size: 14px; 
        padding-right: 5px; 
    }
    .entrybox {
        font-size: 14px; 
        padding-right: 5px; 
    }
    button,
    datalist {
        background-color: #007BC6;
        border: none; 
        border-bottom: 1px solid #002942;
        border-right: 1px solid #002942;
    }
    input[type=text] { 
        width: 100px;
        color: #000000;
        border: none; 
    }
    [type="checkbox"] {
        vertical-align: middle;
        font-size: 14px;
    }
    #topBanner {
        width: calc(100% - 10px);
        overflow: scroll;
        background-color: #B2E4FF;
        padding: 5px;
        margin: 0px;
    }
    #reading-content {
        display: flex;
    }
    #serialResults {
        white-space: pre;
        height: 30%;
        width: 100%;
        border-style: solid;
        overflow-y: scroll;
        background-color: #000000;
        color: #FFFFFF;
        padding: 10px;
        margin: 0px;
        float: left;
    }
    #right-section {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
        margin-top: -23px;
    }
    #right-section2 {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
    }
    #right-section3 {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
    }
    .value-container {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: left;
        width: 100%;
        text-align: left; 
    }
    .value-label {
        color: #000000;
        font-size: 16px;
        margin-bottom: 5px;
    }
    #peak-value {
        background-color: #000000;
        display: flex;
        justify-content: left;
        padding-left: 10px;
        align-items: center;
        color: #0000FF;
        font-size: 16px;
        width: 100%;
        height: 50px;
    }
    #low-value {
        background-color: #000000; 
        display: flex;
        justify-content: left;
        padding-left: 10px;
        align-items: center;
        color: #FF0000;
        font-size: 16px;
        width: 100%;
        height: 50px; 
    }
    
    #button {
        width: 350px;
        height: 25px; 
        color: #FFFFFF;
    }

    #small-button {
        width: 200px;
        height: 25px; 
        color: #FFFFFF;
    }

    .outputBox {
        width: 100%;
        height: 30vh;
        background-color: #000000;
        border: 1px solid;
        box-sizing: border-box;
        color: #FFFFFF;
        font-size: 120px;
        text-align: right; 
        vertical-align: middle;
    }
    /* New styles for horizontal alignment */
    .horizontal-align {
        display: flex;
    }
    .horizontal-align label {
        margin-right: 10px;
    }
    .horizontal-align select {
        flex-grow: 1;
    }

    /* New styles for button container */
    .button-container {
        justify-content: space-between;
        display: flex;
        width: 74%;
        margin: 0px; /* Center the container */
    }

    /* New styles for the scrollable table */
    #table-container {
        width: 100%;
        height: 345px;
        overflow-y: scroll;
        border: 1px solid #ccc;
        background-color: black;
    }

    #data-table {
        width: 100%;
        border-collapse: collapse;
        background-color: black;
    }

    #data-table th, #data-table td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        background-color: black; 
        color: white; 
    }

    #data-table th {
        background-color: black;
    }
    #dataChart {
    background-color: #000000; /* Set the background color to black */
    width: 100%;
    height: 100%;
}
#calibration-table th, #calibration-table td {
    padding: 2px 2px !important;
    font-size: 15px;
    text-align: center;
}
#calibration-table input[type=number] {
    width: 80px;
    height: 22px;
    font-size: 14px;
    padding: 2px 4px;
    margin: 0;
    text-align: right;
}
#calibration-table button {
    color: white;
    width: 48px;
    height: 22px;
    font-size: 13px;
    padding: 0 4px;
    margin: 0;
}
#calibration-table {
    margin-left: 0;
    table-layout: fixed;
}
/* Stylish Burn button */
.burn-btn {
    background-color: #007BC6;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 4px 16px;
    font-size: 15px;
    margin-left: 6px;
    margin-right: 10px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    transition: background 0.18s, box-shadow 0.18s;
    vertical-align: middle;
}
.burn-btn:hover, .burn-btn:focus {
    background-color: #005b8a;
    box-shadow: 0 4px 12px rgba(0,0,0,0.13);
}
/* Remove previous calibration-section/table overrides, keep original white style */
#calib-live-section > div {
  /* Only style the plot and value area, not the table */
}
</style>
</head>
<body>
<div class="horizontal-container" id="topBanner"> 
    <label class="Header_Title" for="ProductName">LoadVUE Pro Cloud - Single Channel Display</label>
    <button id="connect" onclick="connectSerial()" style="margin-right: 98px;height: 36px;font-size: 18px;" class="button">Connect Serial Port</button>
    <button id="disconnect" style="display: none;margin-right: 98px;height: 36px;font-size: 18px;" onclick="disconnectSerial()" class="button">Disconnect</button>
    <img class="right" src="images/loadstar_sensors_logo.png">
</div>
<div id="middle" style="margin-top:10px;">
    <div id="reading-content">
        <div id="outputReading" class="outputBox"></div>   
    </div>
    <!-- New row for controls and Peak/Low -->
    <div id="reading-controls-row" style="display: flex; flex-direction: row; align-items: center; gap: 32px; margin-top: 8px; margin-bottom: 8px; width: 100%;">
        <div class="horizontal-align">
            <label class="value-label">Resolution:</label>
            <select id="resolutionSelect" onchange="return updateResolution()">
                <option value="0">x</option>
                <option value="1">x.x</option>
                <option value="2" selected>x.xx</option>
            </select>
        </div>
        <div class="horizontal-align">
            <label class="value-label">Units:</label>
            <select id="unitSelect" onchange="updateUnits()">
                <option value="lb">lb</option>
                <option value="kg">kg</option>
                <option value="g">g</option>
                <option value="N">N</option>
            </select>
        </div>
        <div class="horizontal-align">
            <label class="value-label">Average:</label>
            <select id="averageReading" onchange="averageReading()">
                <option value="1">1</option>
                <option value="10">10</option>
                <option value="50">50</option>
                <option value="100">100</option>
            </select>
        </div>
        <!-- Peak/Low moved here -->
        <div class="horizontal-align" style="margin-left: 32px;">
            <div class="value-label" style="font-size: 14px;">Peak:</div>
            <div id="peak-value" style="background-color: #000000; color: #0000FF; font-size: 16px; width: 80px; height: 32px; display: flex; align-items: center; justify-content: center; margin-left: 6px;">N/A</div>
        </div>
        <div class="horizontal-align">
            <div class="value-label" style="font-size: 14px;">Low:</div>
            <div id="low-value" style="background-color: #000000; color: #FF0000; font-size: 16px; width: 80px; height: 32px; display: flex; align-items: center; justify-content: center; margin-left: 6px;">N/A</div>
        </div>
    </div>
</div>
<div class="button-container" style="margin-top:5px;">
    <button id="tare"  onclick="tare()" style="color:white; width:49%; height: 25px;display: none;">Tare</button>
    <button id="read" onclick="showReading()" style="color:white; width: 49%; height: 25px; display: none;">Read</button>
    <button id="stop" onclick="stopReading()" style="color:white; width: 49%; height: 25px; display: none;">Stop</button>
</div>

<!-- Force Vs Time Plot -->

<div style="margin-top:10px; margin-bottom: 10px; font-size: 14; font-weight: bold;">
    Force vs Time Plot:&nbsp;<span id="graphtype" style="text-transform: capitalize;"></span></div>
<div style="display: flex; flex-direction: column; width: 100%;">
    <div id="graph-container" style="width: 100%; height: 30vh;">
        <canvas id="dataChart" style="width: 100%; height: 100%;"></canvas>
    </div>  
    <!-- New row for Cumulative/Strip Chart buttons -->
    <div id="chart-controls-row" style="display: flex; flex-direction: row; gap: 10px; margin-top: 10px; width: 100%;">
        <button onclick="showCumulativeGraph()" style="color:white; width: 160px; height: 28px;">Cumulative</button>
        <button onclick="showRecentGraph()" style="color:white; width: 160px; height: 28px;">Strip Chart</button>
    </div>
</div>
<!-- Calibration Utility always visible under the Force vs Time Plot -->
<div id="calibration-section" style="width: 100%; background: none; padding: 0; border-radius: 0; max-width: 100%; min-width: 0; margin: 0; position: relative;">
  <div id="calibration-modal-body">
    <h2 style="margin-bottom: 10px;">Calibration Utility</h2>
    <!-- Tab Bar -->
    <div id="calib-tabs" style="display: flex; gap: 8px; margin-bottom: 18px;">
      <button class="calib-tab-btn" data-tab="specs" style="padding: 8px 18px; border-radius: 6px 6px 0 0; border: none; background: #e0e0e0; color: #333; font-weight: bold;">Specifications</button>
      <button class="calib-tab-btn" data-tab="2pt" style="padding: 8px 18px; border-radius: 6px 6px 0 0; border: none; background: #e0e0e0; color: #333; font-weight: bold;">2-Point Calibration</button>
      <button class="calib-tab-btn" data-tab="multi" style="padding: 8px 18px; border-radius: 6px 6px 0 0; border: none; background: #e0e0e0; color: #333; font-weight: bold;">Multi-Point Calibration</button>
    </div>
    <!-- Tab Contents -->
    <div id="calib-tab-content-specs" class="calib-tab-content">
      <!-- Specifications Tab Content -->
      <div style="display: flex; flex-direction: column; gap: 16px; max-width: 480px; margin-bottom: 10px;">
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="sensorID" style="min-width: 110px;">ID:</label>
          <input type="text" class="entrybox" id="sensorID" style="border: 1.5px solid #888; background: #fff;">
          <button onclick="burnID()" class="burn-btn">Burn</button>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="sensorCapacity" style="min-width: 110px;">Capacity:</label>
          <input type="text" class="entrybox" id="sensorCapacity" style="border: 1.5px solid #888; background: #fff;">
          <button onclick="burnCapacity()" class="burn-btn">Burn</button>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="sensorUnits" style="min-width: 110px;">Units:</label>
          <select id="sensorUnits" onchange="burnUnits()" style="border: 1.5px solid #888; background: #fff;">
            <option value="lb">lb</option>
            <option value="kg">kg</option>
            <option value="g">g</option>
            <option value="N">N</option>
          </select>
          <button onclick="burnUnits()" class="burn-btn">Burn</button>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="ncal-mode" style="min-width: 110px;">Calibration Mode (NCAL):</label>
          <select id="ncal-mode" onchange="setNCALMode()" style="border: 1.5px solid #888; background: #fff;">
            <option value="1">Single Direction (Compression Only)</option>
            <option value="2">Both Directions (Compression + Tension)</option>
          </select>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="baud" style="min-width: 110px;">Baud Rate:</label>
          <input type="number" class="entrybox" id="baud" value="9600" min="1" style="border: 1.5px solid #888; background: #fff;">
        </div>
      </div>
      <div id="specs-summary" style="margin-top: 10px; font-size: 15px; color: #333;"></div>
    </div>
    <div id="calib-tab-content-2pt" class="calib-tab-content" style="display:none;">
      <!-- 2-Point Calibration Tab Content -->
      <div style="margin-bottom: 10px;">
        <strong>2-Point Calibration Instructions:</strong><br>
        1. Enter two different known loads (e.g., 0 and 100)<br>
        2. Click "Capture" for each load to capture the raw sensor values<br>
        3. Click "Calculate Calibration" to see the linear fit<br>
        4. Click "Burn 2-Point Calibration" to save to sensor
      </div>
      <table style="width: 100%; max-width: 400px; margin-bottom: 10px;">
        <tr>
          <th>Load (Known)</th>
          <th>Raw Value</th>
          <th>Action</th>
        </tr>
        <tr>
          <td><input type="number" id="twopt-load1" style="width: 80px;"></td>
          <td id="twopt-raw1">---</td>
          <td><button onclick="read2ptRaw(1)" class="burn-btn">Capture</button></td>
        </tr>
        <tr>
          <td><input type="number" id="twopt-load2" style="width: 80px;"></td>
          <td id="twopt-raw2">---</td>
          <td><button onclick="read2ptRaw(2)" class="burn-btn">Capture</button></td>
        </tr>
      </table>
      <button onclick="calculate2ptCalibration()" class="burn-btn" style="width: 180px;">Calculate Calibration</button>
      <button onclick="burn2ptCalibration()" class="burn-btn" style="width: 180px;">Burn 2-Point Calibration</button>
      <div id="calibration-result-2pt" style="margin-top: 8px; font-size: 15px;"></div>
    </div>
    <div id="calib-tab-content-multi" class="calib-tab-content" style="display:none;">
      <!-- Multi-Point Calibration Tab Content (with both directions) -->
      <div id="calib-live-section" style="width: 100%; max-width: 100vw; margin-bottom: 18px; display: flex; flex-direction: column; align-items: center;">
        <div style="display: flex; flex-direction: row; width: 100%; gap: 0;">
          <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #000; border-radius: 8px 0 0 8px; min-width: 0;">
            <div style="font-size: 32px; color: #FF6384; margin-bottom: 12px; margin-top: 24px; background: #000;">Current Raw Value</div>
            <div id="calib-current-raw" style="width: 100%; height: 180px; background: #000; color: #fff; font-size: 64px; display: flex; align-items: center; justify-content: center; border-radius: 0; border: none; font-family: 'Segoe UI', monospace;">---</div>
          </div>
          <div style="flex: 2; display: flex; flex-direction: column; align-items: center; background: #000; border-radius: 0 8px 8px 0; min-width: 0;">
            <div style="font-size: 32px; color: #FF6384; margin-bottom: 12px; margin-top: 24px; background: #000;">Raw Value Plot</div>
            <canvas id="calib-raw-plot" width="900" height="240" style="background: #000; border-radius: 0; border: none; width: 100%; max-width: 100%;"></canvas>
          </div>
        </div>
        <div style="width: 100%; display: flex; justify-content: center; margin-top: 18px;">
          <button id="calib-plot-toggle" class="burn-btn" style="height: 56px; min-width: 160px; font-size: 24px; background: #007BC6; color: #fff; border-radius: 6px; border: none;">Resume</button>
          <button id="calib-plot-clear" class="burn-btn" style="height: 56px; min-width: 120px; font-size: 24px; background: #d9534f; color: #fff; border-radius: 6px; border: none; margin-left: 12px;">Clear</button>
        </div>
      </div>
      <table id="calibration-table" style="width: 100%; border-collapse: collapse; background-color: #fff; margin-left: 0; table-layout: fixed;">
        <thead>
          <tr>
            <th colspan="4" style="text-align: center; background: #e0e0e0;">Compression</th>
            <th colspan="4" style="text-align: center; background: #f0f0f0;">Tension</th>
          </tr>
          <tr>
            <th style="width: 30px; text-align: center;">#</th>
            <th style="width: 100px; text-align: center;">Known Load</th>
            <th style="width: 100px; text-align: center;">Raw</th>
            <th style="width: 70px; text-align: center;">Capture</th>
            <th style="width: 30px; text-align: center;">#</th>
            <th style="width: 100px; text-align: center;">Known Load</th>
            <th style="width: 100px; text-align: center;">Raw</th>
            <th style="width: 70px; text-align: center;">Capture</th>
          </tr>
        </thead>
        <tbody id="calibration-table-body">
          <!-- Dynamic rows will be rendered here -->
        </tbody>
      </table>
      <div style="margin-top: 10px; display: flex; gap: 10px;">
        <button onclick="calculateCalibration()" style="color:white; width: 160px; height: 28px; font-size: 15px;">Calculate Calibration</button>
        <button onclick="burnCalibration()" style="color:white; width: 160px; height: 28px; font-size: 15px;">Burn Calibration</button>
      </div>
      <div id="calibration-result" style="margin-top: 8px; font-size: 15px;"></div>
    </div>
  </div>
</div>
   
<!-- Log Data -->
<div style="margin-top:20px; margin-bottom: 10px; font-size: 24px; font-weight: bold;">Log Data</div>
<div style="display: flex; width: 100%;">
    <div id="table-container" style="width: 100%; font-size: 12px;">
        <table id="data-table">
            <tbody>
                <!-- Data rows will be dynamically added here -->
            </tbody>
        </table>
    </div>
</div>
<!-- Save Data button row (moved below the table) -->
<div id="save-data-row" style="display: flex; flex-direction: row; justify-content: flex-start; width: 100%; margin-bottom: 6px; margin-top: 6px;">
    <button onclick="saveData()" style="color:white; width: 160px; height: 28px;">Save Data</button>
</div>

<div id="footer" style="background-color: #B2E4FF; text-align: center; padding: 5px; margin-top: 10px;">
Loadstar Sensors Copyright 2025 All Rights Reserved.
</div>

<div id="calibration-modal" style="display:none; position:fixed; z-index:1000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4); justify-content:center; align-items:center;">
  <div id="calibration-modal-content" style="background:#fff; padding:24px 18px 18px 18px; border-radius:8px; min-width:420px; max-width:90vw; max-height:90vh; overflow:auto; position:relative;">
    <button onclick="closeCalibrationModal()" style="position:absolute; top:8px; right:12px; font-size:20px; background:none; color:#333; border:none; cursor:pointer;">&times;</button>
    <div id="calibration-modal-body">
      <h2 style="margin-bottom: 10px;">Calibration Utility</h2>
      <table id="calibration-table" style="width: 100%; border-collapse: collapse; background-color: #fff; margin-left: 0; table-layout: fixed;">
        <thead>
          <tr>
            <th style="width: 60px; padding: 4px 2px; text-align: center;">Point No.</th>
            <th style="width: 120px; padding: 4px 2px; text-align: center;">Known Weight</th>
            <th style="width: 120px; padding: 4px 2px; text-align: center;">Raw Sensor Value</th>
            <th style="width: 70px; padding: 4px 2px; text-align: center;">Action</th>
            <th style="width: 40px; padding: 4px 2px; text-align: center;"></th>
          </tr>
        </thead>
        <tbody id="calibration-table-body">
          <!-- Dynamic rows will be rendered here -->
        </tbody>
      </table>
      <div style="margin-top: 10px; display: flex; gap: 10px;">
        <button onclick="calculateCalibration()" style="color:white; width: 160px; height: 28px; font-size: 15px;">Calculate Calibration</button>
        <button onclick="burnCalibration()" style="color:white; width: 160px; height: 28px; font-size: 15px;">Burn Calibration</button>
      </div>
      <div id="calibration-result" style="margin-top: 8px; font-size: 15px;"></div>
    </div>
  </div>
</div>

<script>
    console.log = function() {}
    var port, textEncoder, writableStreamClosed, writer, historyIndex = -1;
    const lineHistory = [];
    const sensorData = [];
    const timestamps = [];
    let readingInterval = null;  // To manage the live reading update interval
    let peakValue = Number.NEGATIVE_INFINITY;  // Initialize as number
    let lowValue = Number.POSITIVE_INFINITY;   // Initialize as number

    let currentUnit = "lb";  // Default unit
    let currentResolution = 2;  // Default resolution (x.xx)
    const conversionFactors = {
        lb: { lb: 1, kg: 0.453592, g: 453.592, N: 4.44822 },
        kg: { lb: 2.20462, kg: 1, g: 1000, N: 9.81 },
        g: { lb: 453.59, kg: 0.001, g: 1, N: 0.0098 },
        N: { lb: 0.22480, kg: 0.10197, g: 101.972, N: 1 }
    };  // Conversion factors
 
    // Global reader for consistent stream management
    var globalReader ;

    async function connectSerial() {
        
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: parseInt(document.getElementById("baud").value) });
            
            let settings = {};
            if (localStorage.dtrOn == "true") settings.dataTerminalReady = true;
            if (localStorage.rtsOn == "true") settings.requestToSend = true;
            if (Object.keys(settings).length > 0) await port.setSignals(settings);
  
            textEncoder = new TextEncoderStream();
            writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
            writer = textEncoder.writable.getWriter();

            // Create a global reader for managing the stream
            if (!globalReader) {
                globalReader = port.readable.getReader();
            }

            // Fetch and display sensor capacity after connecting
            const capacityValue = await fetchSensorCapacity();
            document.getElementById("sensorCapacity").value = capacityValue;

            // Fetch and display sensor ID after connecting
            const sensorID = await fetchSensorID();
            document.getElementById("sensorID").value = sensorID;

            // Fetch and display sensor units after connecting
            const sensorUnits = await fetchSensorUnits();
            // Normalize and set sensorUnits dropdown
            if (sensorUnits) {
                let normalized = sensorUnits.trim();
                if (normalized.toLowerCase() === 'n') normalized = 'N';
                if (["lb", "kg", "g", "N"].includes(normalized)) {
                    document.getElementById("sensorUnits").value = normalized;
                } else {
                    document.getElementById("sensorUnits").value = "lb";
                }
            }

        document.getElementById("connect").style.display = "none";
        document.getElementById("disconnect").style.display = "block";
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "block";
        document.getElementById("tare").style.display = "block";
        } catch (e){
        document.getElementById("connect").style.display = "block";
        document.getElementById("disconnect").style.display = "none";
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "none";
        document.getElementById("tare").style.display = "none";
            alert("Serial Connection Failed: " + e);
        }
    }

    async function disconnectSerial() {
        if (port) {
            try {
                document.getElementById("disconnect").textContent ='disconnecting please wait...';
                document.getElementById("disconnect").disabled = true;
                if (writer) {
                    await writer.close();
                    await writableStreamClosed;
                }
                if (globalReader) {
                    await globalReader.cancel();
                    globalReader.releaseLock();
                    globalReader = null;
                }
                await port.close();
                alert("Serial Connection Closed Successfully");
                window.location.reload();
            } catch (e) {
                alert("Failed to close serial connection: " + e);
            } finally {
                port = null;
                writer = null;
                textEncoder = null;
                document.getElementById("disconnect").textContent ='Disconnect';
                document.getElementById("disconnect").disabled = false;
                document.getElementById("connect").style.display = "block";
                document.getElementById("disconnect").style.display = "none";
                document.getElementById("stop").style.display = "none";
                document.getElementById("read").style.display = "none";
                document.getElementById("tare").style.display = "none";
                clearInterval(readingInterval);  // Stop live reading updates
                document.getElementById("sensorID").value = "";
                document.getElementById("sensorCapacity").value = "";
                document.getElementById("sensorUnits").value = "";
            }
        } else {
            alert("No serial connection to close");
        }
    }

    // async function sendCharacterNumber() {
    //     document.getElementById("lineToSend").value = String.fromCharCode(document.getElementById("lineToSend").value);
    // }

    // const serialResultsDiv = document.getElementById("serialResults"); 
    // async function appendToTerminal(newStuff) {
    //     serialResultsDiv.innerHTML += newStuff;
    //     if (serialResultsDiv.innerHTML.length > 3000) serialResultsDiv.innerHTML = serialResultsDiv.innerHTML.slice(serialResultsDiv.innerHTML.length - 3000);
    //     serialResultsDiv.scrollTop = serialResultsDiv.scrollHeight;
    // }

//     function scrollHistory(direction) {
//         historyIndex = Math.max(Math.min(historyIndex + direction, lineHistory.length - 1), -1);
//         if (historyIndex >= 0) {
//             document.getElementById("lineToSend").value = lineHistory[historyIndex];
//         } else {
//             document.getElementById("lineToSend").value = "";
//         }
//     }
// window.onload = function() {
//     document.getElementById("lineToSend").addEventListener("keyup", async function (event) {
//         if (event.keyCode === 13) {
//             sendSerialLine();
//         } else if (event.keyCode === 38) {
//             scrollHistory(1);
//         } else if (event.keyCode === 40) {
//             scrollHistory(-1);
//         }
//     });
//     };
    

    //document.getElementById("baud").value = (localStorage.baud == undefined ? 9600 : localStorage.baud);
   // document.getElementById("addLine").checked = (localStorage.addLine == "false" ? false : true);
    //document.getElementById("carriageReturn").checked = (localStorage.carriageReturn == "false" ? false : true);
    //document.getElementById("echoOn").checked = (localStorage.echoOn == "false" ? false : true);

    // async function populateConnections() {
    //     const ports = await navigator.serial.getPorts();
    //     const connectionsSelect = document.getElementById('connections');
    //     connectionsSelect.innerHTML = ''; 

    //     ports.forEach((port, index)=> {
    //         const option = document.createElement('option');
    //         option.value = `port${index}`;
    //         option.textContent = `Port ${index + 1}`;
    //         connectionsSelect.appendChild(option);
    //     });
    // }

    async function fetchSensorCapacity() {
        const command = 'slc\r';  // Command to request sensor capacity
        try {
            let result = '';
            console.log('Sending capacity request command:', command);

            // Send the capacity command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            console.log('Reading capacity from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the capacity to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received capacity:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading capacity:', error);
            return "Error retrieving capacity";
        }
    }

    async function fetchSensorID() {
        const command = 'ss1\r';  // Command to request sensor ID
        try {
            console.log('Sending ID request command:', command);

            // Send the ID command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading ID from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                // console.log('Received chunk:', value);
                // console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the ID to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            // console.log('Final received ID:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading ID:', error);
            return "Error retrieving ID";
        }
    }

    async function tareCmd() {
        const command = 'ct0\r';
        try {
            await writer.write(command);
            console.log('Command:%s sent successfully.',command);
            const decoder = new TextDecoder();
            let result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read for Tare.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Tare Received chunk:', value);
                console.log('Tare Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the units to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }
        } catch (error) {
            console.error('error in tare command:%O', error)
        }
    }
    async function fetchSensorUnits() {
        const command = 'unit\r';  // Command to request sensor units, assuming 'unit' is the command for units
        try {
            console.log('Sending units request command:', command);

            // Send the units command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading units from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the units to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received units:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading units:', error);
            return "Error retrieving units";
        }
    }

    async function fetchSensorData() {
        const command = 'o0w1\r';  // Command to request sensor data
        try {
            console.log('Sending data request command:', command);

            // Send the data command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading data from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the data to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received data:', result);
            return parseFloat(result.trim()).toFixed(2);
        } catch (error) {
            console.error('Error reading data:', error);
            return "Error retrieving data";
        }
    }

    async function showCapacityNew() {
        const capacityValue = await fetchSensorCapacity();
        document.getElementById("outputCapacity").textContent = `Capacity: ${capacityValue}`;
    }
function stopReading() {
    isStart = false;
        if (readingInterval) {
            clearInterval(readingInterval);  // Clear any existing interval
        }
        // disable the stop button and enable read and tare buttons
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "block";
        // document.getElementById("tare").style.display = "block";
    }
    let isStart = false;
    let avgCount = 1;
    async function showReading() {
        if (pollingMode === 'calibration') {
            alert('Pause the calibration plot to resume main display reading.');
            return;
        }
        if (readingInterval) {
            clearInterval(readingInterval);  // Clear any existing interval
        }
        document.getElementById("stop").style.display = "block";
        document.getElementById("read").style.display = "none";
        isStart = true;
        let sum =0, avg=0,isPush=false, counter=0;
        readingInterval = setInterval(async () => {
            const rawValue = await fetchRawSensorValue();
            let slope = window._calibSlope;
            let intercept = window._calibIntercept;
            let displayValue, convertedData;
            if (typeof slope === 'number' && typeof intercept === 'number' && !isNaN(slope) && !isNaN(intercept) && slope !== 0) {
                const weight = (parseFloat(rawValue) - intercept) / slope;
                convertedData = weight;
                displayValue = `${weight.toFixed(currentResolution)} ${_currentUnit}`;
            } else {
                convertedData = parseFloat(rawValue);
                displayValue = `${rawValue} (raw)`;
            }
            if(counter<avgCount) {
                isPush = false;
                sum+=parseFloat(convertedData);
                counter++;
            } else {
                avg = sum/avgCount;
                sum=0;
                counter=0;
                isPush=true;
            }
            const _convertedData = avg.toFixed(currentResolution);
            const now = new Date().toLocaleTimeString();
            if(isPush){
                document.getElementById("outputReading").textContent = displayValue;
                chartData.push(_convertedData);
                chartLabels.push(now);
                addToTable(now, `${_convertedData}`);
                if (chartMode === 'cumulative') {
                    showCumulativeGraph();
                } else if (chartMode === 'recent') {
                    showRecentGraph();
                }
                // Ensure peakValue and lowValue are numbers
                if (typeof convertedData === 'string') convertedData = parseFloat(convertedData);
                if (convertedData > peakValue || !isFinite(peakValue)) {
                    peakValue = convertedData;
                    document.getElementById("peak-value").textContent = isFinite(peakValue) ? peakValue.toFixed(currentResolution) : "N/A";
                }
                if (convertedData < lowValue || !isFinite(lowValue)) {
                    lowValue = convertedData;
                    document.getElementById("low-value").textContent = isFinite(lowValue) ? lowValue.toFixed(currentResolution) : "N/A";
                }
            }
        }, 100);
    }

    async function tare() {
        stopReading()
        if(chartData.length) {
        clearTable();
        chartLabels = []
        chartData = []
        showCumulativeGraph()
        }        
        // Reset current reading to zero
        document.getElementById("outputReading").textContent = `0.00 ${_currentUnit}`;

        // Reset peak and low values to N/A
        peakValue = Number.NEGATIVE_INFINITY;
        lowValue = Number.POSITIVE_INFINITY;
        document.getElementById("peak-value").textContent = `N/A`;
        document.getElementById("low-value").textContent = `N/A`;
        await tareCmd();
    }
var _currentUnit = currentUnit;
    function updateUnits() {
    if(document.getElementById("unitSelect").value!=_currentUnit)
    {
    if(confirm("Unit changes in mid of reading, may clear all prev readings. do you want to clear all prev data?"))
    {
        stopReading();
    }
    }
        _currentUnit = document.getElementById("unitSelect").value;
  removeTableHead();
        createTableHead();
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  const table = tableBody.parentElement; // Get the table element
  table.insertBefore(createTableHead(), tableBody); // Insert the table head before the table body
        console.log('Units changed to:', currentUnit);
    }
    function averageReading() {
        /*
        if(isStart)
        {
            alert("Average changes in mid of reading is not allowed. Please stop reading, change average and start again");
            
            return false;
        } 
            */
            avgCount = parseInt(document.getElementById("averageReading").value);
    }
    function updateResolution() {
        if(isStart)
        {
            alert("Resolution changes in mid of reading is not allowed. Please stop reading, change resolution and start again");
            document.getElementById("resolutionSelect").value = currentResolution;
            return false;
        }
        currentResolution = parseInt(document.getElementById("resolutionSelect").value);
        console.log('Resolution changed to:', currentResolution);
        return true;
    }

    function convertUnits(value) {
        const _conversionFactors = conversionFactors[currentUnit];
        console.log('selected unit conversion units:',_conversionFactors);
        return (value * _conversionFactors[_currentUnit]).toFixed(currentResolution);
    }

function clearTable() {
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  // Using a while loop (more explicit)
  while (tableBody.firstChild) {
    tableBody.removeChild(tableBody.firstChild); 
  }
}
    // Function to add a row to the table
    function addToTable(time, reading) {
        const tableBody = document.querySelector("#data-table tbody");
        const newRow = document.createElement("tr");

        const timeCell = document.createElement("td");
        timeCell.textContent = time;
        timeCell.style.backgroundColor = "#000000"; // Set background color to black
        timeCell.style.color = "#ffffff"; // Set text color to white
        newRow.appendChild(timeCell);

        const readingCell = document.createElement("td");
        readingCell.textContent = reading;
        readingCell.style.backgroundColor = "#000000"; // Set background color to black
        readingCell.style.color = "#ffffff"; // Set text color to white
        newRow.appendChild(readingCell);


    const peakCell = document.createElement("td");
    peakCell.textContent = isFinite(peakValue) ? peakValue.toFixed(currentResolution) : "N/A"; // Display the current peak value
    peakCell.style.backgroundColor = "#000000"; // Set background color to black
    peakCell.style.color = "#ffffff"; // Set text color to white
    newRow.appendChild(peakCell);

    const lowCell = document.createElement("td");
    lowCell.textContent = isFinite(lowValue) ? lowValue.toFixed(currentResolution) : "N/A"; // Display the current low value
    lowCell.style.backgroundColor = "#000000"; // Set background color to black
    lowCell.style.color = "#ffffff"; // Set text color to white
    newRow.appendChild(lowCell);

        tableBody.prepend(newRow);
    }

    function saveData() {
    // Gather necessary information
    const sensorID = document.getElementById("sensorID").value;
    const sensorCapacity = document.getElementById("sensorCapacity").value;
    const sensorUnits = document.getElementById("sensorUnits").value;
    const testDate = new Date().toLocaleDateString();  // Format the date as needed

    // CSV file content
    let csvContent = `Data Log\n`;
    csvContent += `ID: ${sensorID}\n`;
    csvContent += `Capacity: ${sensorCapacity}\n`;
    csvContent += `Units: ${sensorUnits}\n`;
    csvContent += `Test Date: ${testDate}\n\n`;

    // Add table headers
    csvContent += `Time,Reading,Peak,Low\n`;

    // Loop through the table and add the data to the CSV
    const tableRows = document.querySelectorAll("#data-table tbody tr");
    tableRows.forEach(row => {
        const cells = row.querySelectorAll("td");
        const rowData = Array.from(cells).map(cell => cell.textContent).join(",");
        csvContent += `${rowData}\n`;
    });

    // Create a Blob with the CSV content
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

    // Prompt the user to name the file
    const fileName = prompt("Enter a name for the CSV file:", "data_log");

    // Create a link to download the file
    if (fileName) {
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `${fileName}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

</script>

<script>
    var chart; // Global chart instance
    var chartData = []; // Array to hold the data points
    var chartLabels = []; // Array to hold the labels (timestamps)
    var chartMode = 'cumulative'; // Track the current chart mode

    // Initialize Chart.js chart
    function initializeChart() {
        var ctx = document.getElementById('dataChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line', // Line chart
            data: {
                labels: chartLabels,
                datasets: [{
                    label: 'Sensor Reading',
                    backgroundColor: 'rgba(0, 0, 0, 0)', // Transparent background for the line
                    borderColor: 'rgba(255, 99, 132, 1)',
                    data: chartData,
                    fill: false,
                }]
            },
            options: {
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgba(255, 255, 255, 0.1)' // Lighter grid lines for better visibility
                        },
                        type: 'time',
                        time: {
                            unit: 'second',
                            displayFormats: {
                                second: 'h:mm:ss a'
                            }
                        }
                    }],
                    yAxes: [{
                        gridLines: {
                            color: 'rgba(255, 255, 255, 0.1)' // Lighter grid lines for better visibility
                        }
                    }]
                },
                elements: {
                    line: {
                        tension: 0 // Disable bezier curves for better performance
                    }
                },
                plugins: {
                    decimation: {
                        enabled: true,
                        algorithm: 'min-max', // Choose the decimation algorithm
                        samples: 5000 // Number of samples to keep
                    }
                }
            }
        });
    }

    // Function to show the cumulative graph (default mode)
    function showCumulativeGraph() {
        chartMode = 'cumulative';
        chart.data.labels = chartLabels;
        chart.data.datasets[0].data = chartData;
        chart.update();
    }

    // Function to show only the most recent 5 values
    function showRecentGraph() {
        chartMode = 'recent';
        var recentLabels = chartLabels.slice(-10);  // Get the last 5 labels
        var recentData = chartData.slice(-10);  // Get the last 5 data points
        chart.data.labels = recentLabels;
        chart.data.datasets[0].data = recentData;
        chart.update();
    }

    // Call initializeChart() on document ready
    document.addEventListener('DOMContentLoaded', function() {
        initializeChart();
        createTableHead();
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  const table = tableBody.parentElement; // Get the table element
  table.insertBefore(createTableHead(), tableBody); // Insert the table head before the table body
  document.getElementById("graphtype").textContent = chartMode === 'cumulative'? 'Cumulative': 'Strip Chart';
    });
    function removeTableHead() {
    const table = document.querySelector('#data-table');
    const tableHead = table.querySelector('thead');
    if (tableHead) {
      table.removeChild(tableHead);
    }
  }
    function createTableHead() {
    const tableHead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    const headers = ["Time", "Reading"+` (${_currentUnit})`, "Peak"+` (${_currentUnit})`, "Low"+` (${_currentUnit})`];
    headers.forEach(headerText => {
      const headerCell = document.createElement("th");
      headerCell.textContent = headerText; // Set the header text
      headerCell.style.fontWeight = "normal"; // Set normal font weight
      headerRow.appendChild(headerCell);
    });

    tableHead.appendChild(headerRow);
    return tableHead;
  }
</script>

<script>
// Store calibration data for both directions
globalThis.calibrationPointsCompression = [];
globalThis.calibrationPointsTension = [];
const MIN_CALIB_ROWS = 1;
const DEFAULT_CALIB_ROWS = 9;
let ncalMode = 1; // 1 = compression only, 2 = both

function setNCALMode() {
  ncalMode = parseInt(document.getElementById('ncal-mode').value);
  renderCalibrationTable();
}

function renderCalibrationTable() {
  const tbody = document.getElementById('calibration-table-body');
  tbody.innerHTML = '';
  for (let idx = 0; idx < Math.max(calibrationPointsCompression.length, calibrationPointsTension.length); idx++) {
    const tr = document.createElement('tr');
    // Compression Row Number
    const tdCompNum = document.createElement('td');
    tdCompNum.style.textAlign = 'center';
    tdCompNum.textContent = idx + 1;
    tr.appendChild(tdCompNum);
    // Compression Known Load
    const tdCompLoad = document.createElement('td');
    const inputCompLoad = document.createElement('input');
    inputCompLoad.type = 'number';
    inputCompLoad.id = `comp-load-${idx+1}`;
    inputCompLoad.style.width = '80px';
    inputCompLoad.style.height = '22px';
    inputCompLoad.style.fontSize = '14px';
    inputCompLoad.style.textAlign = 'center';
    inputCompLoad.placeholder = 'Enter';
    inputCompLoad.value = calibrationPointsCompression[idx]?.weight ?? '';
    inputCompLoad.onchange = (e) => { calibrationPointsCompression[idx].weight = parseFloat(e.target.value); };
    tdCompLoad.appendChild(inputCompLoad);
    tr.appendChild(tdCompLoad);
    // Compression Raw
    const tdCompRaw = document.createElement('td');
    tdCompRaw.id = `comp-raw-${idx+1}`;
    tdCompRaw.style.textAlign = 'center';
    tdCompRaw.textContent = calibrationPointsCompression[idx]?.raw !== undefined && calibrationPointsCompression[idx]?.raw !== null ? calibrationPointsCompression[idx].raw.toFixed(2) : '---';
    tr.appendChild(tdCompRaw);
    // Compression Read + Add/Remove
    const tdCompRead = document.createElement('td');
    tdCompRead.style.display = 'flex';
    tdCompRead.style.alignItems = 'center';
    const btnCompRead = document.createElement('button');
    btnCompRead.textContent = 'Capture';
    btnCompRead.style.color = 'white';
    btnCompRead.style.width = '60px';
    btnCompRead.style.height = '22px';
    btnCompRead.style.fontSize = '13px';
    btnCompRead.onclick = () => readCalibrationRaw(idx+1, 'compression');
    tdCompRead.appendChild(btnCompRead);
    // Add button (only on last row)
    if (idx === calibrationPointsCompression.length - 1) {
      const btnAdd = document.createElement('button');
      btnAdd.textContent = '+';
      btnAdd.title = 'Add row';
      btnAdd.style.color = 'white';
      btnAdd.style.backgroundColor = '#007BC6';
      btnAdd.style.width = '25px';
      btnAdd.style.height = '22px';
      btnAdd.style.fontSize = '13px';
      btnAdd.style.marginLeft = '6px';
      btnAdd.onclick = () => addCalibrationRow('compression');
      tdCompRead.appendChild(btnAdd);
    }
    // Remove button (if more than min rows)
    if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
      const btnRemove = document.createElement('button');
      btnRemove.textContent = '✕';
      btnRemove.title = 'Remove row';
      btnRemove.style.color = 'white';
      btnRemove.style.backgroundColor = '#d9534f';
      btnRemove.style.width = '28px';
      btnRemove.style.height = '22px';
      btnRemove.style.fontSize = '15px';
      btnRemove.style.marginLeft = '6px';
      btnRemove.onclick = () => removeCalibrationRow(idx);
      tdCompRead.appendChild(btnRemove);
    }
    tr.appendChild(tdCompRead);
    // Tension Row Number
    const tdTenNum = document.createElement('td');
    tdTenNum.style.textAlign = 'center';
    tdTenNum.textContent = idx + 1;
    tr.appendChild(tdTenNum);
    // Tension Known Load
    const tdTenLoad = document.createElement('td');
    const inputTenLoad = document.createElement('input');
    inputTenLoad.type = 'number';
    inputTenLoad.id = `ten-load-${idx+1}`;
    inputTenLoad.style.width = '80px';
    inputTenLoad.style.height = '22px';
    inputTenLoad.style.fontSize = '14px';
    inputTenLoad.style.textAlign = 'center';
    inputTenLoad.placeholder = 'Enter';
    inputTenLoad.value = calibrationPointsTension[idx]?.weight ?? '';
    inputTenLoad.onchange = (e) => { calibrationPointsTension[idx].weight = parseFloat(e.target.value); };
    if (ncalMode === 1) { inputTenLoad.disabled = true; inputTenLoad.style.background = '#eee'; }
    tdTenLoad.appendChild(inputTenLoad);
    tr.appendChild(tdTenLoad);
    // Tension Raw
    const tdTenRaw = document.createElement('td');
    tdTenRaw.id = `ten-raw-${idx+1}`;
    tdTenRaw.style.textAlign = 'center';
    tdTenRaw.textContent = calibrationPointsTension[idx]?.raw !== undefined && calibrationPointsTension[idx]?.raw !== null ? calibrationPointsTension[idx].raw.toFixed(2) : '---';
    if (ncalMode === 1) { tdTenRaw.style.background = '#eee'; }
    tr.appendChild(tdTenRaw);
    // Tension Read + Add/Remove
    const tdTenRead = document.createElement('td');
    tdTenRead.style.display = 'flex';
    tdTenRead.style.alignItems = 'center';
    const btnTenRead = document.createElement('button');
    btnTenRead.textContent = 'Capture';
    btnTenRead.style.color = 'white';
    btnTenRead.style.width = '60px';
    btnTenRead.style.height = '22px';
    btnTenRead.style.fontSize = '13px';
    btnTenRead.onclick = () => readCalibrationRaw(idx+1, 'tension');
    if (ncalMode === 1) { btnTenRead.disabled = true; btnTenRead.style.background = '#eee'; }
    tdTenRead.appendChild(btnTenRead);
    // Add button (only on last row)
    if (idx === calibrationPointsTension.length - 1) {
      const btnAdd = document.createElement('button');
      btnAdd.textContent = '+';
      btnAdd.title = 'Add row';
      btnAdd.style.color = 'white';
      btnAdd.style.backgroundColor = '#007BC6';
      btnAdd.style.width = '25px';
      btnAdd.style.height = '22px';
      btnAdd.style.fontSize = '13px';
      btnAdd.style.marginLeft = '6px';
      btnAdd.onclick = () => addCalibrationRow('tension');
      if (ncalMode !== 1) tdTenRead.appendChild(btnAdd);
    }
    // Remove button (if more than min rows)
    if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
      const btnRemove = document.createElement('button');
      btnRemove.textContent = '✕';
      btnRemove.title = 'Remove row';
      btnRemove.style.color = 'white';
      btnRemove.style.backgroundColor = '#d9534f';
      btnRemove.style.width = '28px';
      btnRemove.style.height = '22px';
      btnRemove.style.fontSize = '15px';
      btnRemove.style.marginLeft = '6px';
      btnRemove.onclick = () => removeCalibrationRow(idx);
      if (ncalMode !== 1) tdTenRead.appendChild(btnRemove);
    }
    tr.appendChild(tdTenRead);
    tbody.appendChild(tr);
  }
}
function addCalibrationRow(direction) {
  // Always add a row to both arrays to keep them aligned
  calibrationPointsCompression.push({ weight: null, raw: null });
  calibrationPointsTension.push({ weight: null, raw: null });
  renderCalibrationTable();
}
function removeCalibrationRow(idx) {
  // Only remove if both arrays have more than the minimum rows
  if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
    calibrationPointsCompression.splice(idx, 1);
    calibrationPointsTension.splice(idx, 1);
    renderCalibrationTable();
  }
}
// Initialize calibration points
(function() {
  calibrationPointsCompression = Array(DEFAULT_CALIB_ROWS).fill().map(() => ({ weight: null, raw: null }));
  calibrationPointsTension = Array(DEFAULT_CALIB_ROWS).fill().map(() => ({ weight: null, raw: null }));
  document.addEventListener('DOMContentLoaded', renderCalibrationTable);
})();
// Update readCalibrationRaw to use direction
async function readCalibrationRaw(idx, direction) {
  let weightInput, rawCell, arr;
  if (direction === 'compression') {
    weightInput = document.getElementById(`comp-load-${idx}`);
    rawCell = document.getElementById(`comp-raw-${idx}`);
    arr = calibrationPointsCompression;
  } else {
    weightInput = document.getElementById(`ten-load-${idx}`);
    rawCell = document.getElementById(`ten-raw-${idx}`);
    arr = calibrationPointsTension;
  }
  const weight = parseFloat(weightInput.value);
  if (isNaN(weight)) {
    alert('Please enter a known load before reading.');
    return;
  }
  rawCell.textContent = 'Averaging...';
  const avgRawValue = await getMovingAverageRawValue(100, 10);
  if (isNaN(avgRawValue)) {
    rawCell.textContent = 'Error';
    alert('Failed to get a valid average raw value.');
    return;
  }
  rawCell.textContent = avgRawValue.toFixed(2);
  arr[idx - 1] = { weight, raw: avgRawValue };
}

function calculateCalibration() {
  let points = [];
  if (ncalMode === 1) {
    points = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
  } else {
    // Merge valid points from both arrays
    const comp = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    const ten = calibrationPointsTension.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    points = comp.concat(ten);
  }
  if (points.length < 2) {
    document.getElementById('calibration-result').textContent = 'At least 2 points are required for calibration.';
    return;
  }
  // Linear regression (raw = slope * weight + intercept)
  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, n = points.length;
  for (const pt of points) {
    sumX += pt.weight;
    sumY += pt.raw;
    sumXY += pt.weight * pt.raw;
    sumXX += pt.weight * pt.weight;
  }
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  let resultText = `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>`;
  // Store for burning
  window._calibSlope = slope;
  window._calibIntercept = intercept;
  // If at least 4 points, also show cubic fit
  if (points.length >= 4) {
    const x = points.map(pt => pt.weight);
    const y = points.map(pt => pt.raw);
    function cubicFit(x, y) {
      const n = x.length;
      let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumX5 = 0, sumX6 = 0;
      let sumY = 0, sumXY = 0, sumX2Y = 0, sumX3Y = 0;
      for (let i = 0; i < n; i++) {
        const xi = x[i], yi = y[i];
        const xi2 = xi * xi, xi3 = xi2 * xi, xi4 = xi3 * xi, xi5 = xi4 * xi, xi6 = xi5 * xi;
        sumX += xi;
        sumX2 += xi2;
        sumX3 += xi3;
        sumX4 += xi4;
        sumX5 += xi5;
        sumX6 += xi6;
        sumY += yi;
        sumXY += xi * yi;
        sumX2Y += xi2 * yi;
        sumX3Y += xi3 * yi;
      }
      const A = [
        [sumX6, sumX5, sumX4, sumX3],
        [sumX5, sumX4, sumX3, sumX2],
        [sumX4, sumX3, sumX2, sumX],
        [sumX3, sumX2, sumX, n]
      ];
      const B = [sumX3Y, sumX2Y, sumXY, sumY];
      function gauss(A, B) {
        const n = B.length;
        for (let i = 0; i < n; i++) {
          let maxRow = i;
          for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
          }
          [A[i], A[maxRow]] = [A[maxRow], A[i]];
          [B[i], B[maxRow]] = [B[maxRow], B[i]];
          for (let k = i + 1; k < n; k++) {
            const c = A[k][i] / A[i][i];
            for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
            B[k] -= c * B[i];
          }
        }
        const x = Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
          x[i] = B[i];
          for (let j = i + 1; j < n; j++) x[i] -= A[i][j] * x[j];
          x[i] /= A[i][i];
        }
        return x;
      }
      return gauss(A, B); // [a, b, c, d]
    }
    const [CCA, CCB, CCC, CCD] = cubicFit(x, y);
    resultText += `<br>Cubic fit: raw = (${CCA.toExponential(6)})*weight^3 + (${CCB.toExponential(6)})*weight^2 + (${CCC.toExponential(6)})*weight + (${CCD.toExponential(6)})`;
  }
  // Show which points were used
  if (ncalMode === 1) {
    resultText += '<br><em>Used only compression points.</em>';
  } else {
    resultText += '<br><em>Used both compression and tension points.</em>';
  }
  document.getElementById('calibration-result').innerHTML = resultText;
}

async function burnCalibration() {
  let validPoints = [];
  if (ncalMode === 1) {
    validPoints = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
  } else {
    const comp = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    const ten = calibrationPointsTension.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    validPoints = comp.concat(ten);
  }
  if (validPoints.length < 4) {
    alert('At least 4 calibration points are required for cubic calibration.');
    return;
  }
  // Prepare arrays for cubic fit
  const x = validPoints.map(pt => pt.weight);
  const y = validPoints.map(pt => pt.raw);
  // Cubic fit using least squares (returns [a, b, c, d] for ax^3 + bx^2 + cx + d)
  function cubicFit(x, y) {
    const n = x.length;
    let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumX5 = 0, sumX6 = 0;
    let sumY = 0, sumXY = 0, sumX2Y = 0, sumX3Y = 0;
    for (let i = 0; i < n; i++) {
      const xi = x[i], yi = y[i];
      const xi2 = xi * xi, xi3 = xi2 * xi, xi4 = xi3 * xi, xi5 = xi4 * xi, xi6 = xi5 * xi;
      sumX += xi;
      sumX2 += xi2;
      sumX3 += xi3;
      sumX4 += xi4;
      sumX5 += xi5;
      sumX6 += xi6;
      sumY += yi;
      sumXY += xi * yi;
      sumX2Y += xi2 * yi;
      sumX3Y += xi3 * yi;
    }
    // Solve the normal equations for cubic fit
    const A = [
      [sumX6, sumX5, sumX4, sumX3],
      [sumX5, sumX4, sumX3, sumX2],
      [sumX4, sumX3, sumX2, sumX],
      [sumX3, sumX2, sumX, n]
    ];
    const B = [sumX3Y, sumX2Y, sumXY, sumY];
    // Gaussian elimination
    function gauss(A, B) {
      const n = B.length;
      for (let i = 0; i < n; i++) {
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
        }
        [A[i], A[maxRow]] = [A[maxRow], A[i]];
        [B[i], B[maxRow]] = [B[maxRow], B[i]];
        for (let k = i + 1; k < n; k++) {
          const c = A[k][i] / A[i][i];
          for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
          B[k] -= c * B[i];
        }
      }
      const x = Array(n).fill(0);
      for (let i = n - 1; i >= 0; i--) {
        x[i] = B[i];
        for (let j = i + 1; j < n; j++) x[i] -= A[i][j] * x[j];
        x[i] /= A[i][i];
      }
      return x;
    }
    return gauss(A, B); // [a, b, c, d]
  }
  // Fit cubic: raw = a*x^3 + b*x^2 + c*x + d
  const [CCA, CCB, CCC, CCD] = cubicFit(x, y);
  // Use the first raw value as FAZ (offset)
  const FAZ = validPoints[0].raw;
  // Show the cubic fit equation and coefficients
  document.getElementById('calibration-result').textContent =
    `Cubic fit: raw = (${CCA.toExponential(6)})*weight^3 + (${CCB.toExponential(6)})*weight^2 + (${CCC.toExponential(6)})*weight + (${CCD.toExponential(6)})\nFAZ = ${FAZ}` + (ncalMode === 2 ? '\n(Used both compression and tension points)' : '\n(Used only compression points)');
  // Send the coefficients to the sensor for universal calibration
  try {
    await writer.write(`ncal ${ncalMode}\r`); // Set NCAL mode
    await delay(500);
    await writer.write(`CCA ${CCA}\r`);
    await delay(500);
    await writer.write(`CCB ${CCB}\r`);
    await delay(500);
    await writer.write(`CCC ${CCC}\r`);
    await delay(500);
    await writer.write(`CCD ${CCD}\r`);
    await delay(500);
    await writer.write(`FAZ ${FAZ}\r`);
    await delay(500);
    alert('Cubic (curve fit) calibration burned successfully!');
  } catch (e) {
    alert('Failed to burn cubic calibration: ' + e);
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Helper function to get moving average of N raw sensor values
async function getMovingAverageRawValue(numReadings = 100, delayMs = 10) {
  const readings = [];
  for (let i = 0; i < numReadings; i++) {
    const rawValue = await fetchRawSensorValue();
    const parsed = parseFloat(rawValue);
    if (!isNaN(parsed)) readings.push(parsed);
    await delay(delayMs); // Small delay to avoid overwhelming the sensor
  }
  // Calculate average
  const sum = readings.reduce((a, b) => a + b, 0);
  return (readings.length > 0) ? (sum / readings.length) : NaN;
}

// Restore fetchRawSensorValue globally
async function fetchRawSensorValue() {
  // Sends 'R\r' to get the raw ADC value from the sensor
  const command = 'R\r';
  try {
    await writer.write(command);
    const decoder = new TextDecoder();
    let result = '';
    while (true) {
      const { value, done } = await globalReader.read();
      if (done) break;
      result += decoder.decode(value);
      if (result.includes('\n')) break;
    }
    // Extract the first number from the result
    const match = result.match(/-?\d+(?:\.\d+)?/);
    return match ? match[0] : result.trim();
  } catch (error) {
    console.error('Error reading raw ADC value:', error);
    return 'Error';
  }
}

function openCalibrationModal() {
  document.getElementById('calibration-modal').style.display = 'flex';
}
function closeCalibrationModal() {
  document.getElementById('calibration-modal').style.display = 'none';
}

async function burnID() {
    const newID = document.getElementById("sensorID").value;
    if (!newID) { alert("ID cannot be empty"); return; }
    try {
        await writer.write(`ss1 ${newID}\r`);
        alert("ID burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn ID: " + e);
    }
}
async function burnCapacity() {
    const newCap = document.getElementById("sensorCapacity").value;
    if (!newCap) { alert("Capacity cannot be empty"); return; }
    try {
        await writer.write(`slc ${newCap}\r`);
        alert("Capacity burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn Capacity: " + e);
    }
}
async function burnUnits() {
    const newUnits = document.getElementById("sensorUnits").value;
    if (!newUnits) { alert("Units cannot be empty"); return; }
    try {
        await writer.write(`unit ${newUnits}\r`);
        alert("Units burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn Units: " + e);
    }
}
// Calibration live raw value/plot state
let calibPlotRunning = false; // Start paused by default
let calibRawHistory = [];
const CALIB_RAW_HISTORY_MAX = 100;
let calibRawPlot = null;
let calibRawInterval = null;

// Add global state for polling control
let pollingMode = 'main'; // 'main' or 'calibration'

// Patch calibration plot controls to pause/resume main display polling
function stopMainDisplayPolling() {
  if (readingInterval) {
    clearInterval(readingInterval);
    readingInterval = null;
    document.getElementById("stop").style.display = "none";
    document.getElementById("read").style.display = "block";
  }
  isStart = false;
}
function allowMainDisplayPolling() {
  // No-op: showReading can be called by user
}
// Patch calibration plot toggle
function stopCalibRawPlot() {
  calibPlotRunning = false;
  document.getElementById('calib-plot-toggle').textContent = 'Resume';
  pollingMode = 'main';
  allowMainDisplayPolling();
}
function resumeCalibRawPlot() {
  calibPlotRunning = true;
  document.getElementById('calib-plot-toggle').textContent = 'Pause';
  pollingMode = 'calibration';
  stopMainDisplayPolling();
}
// Patch calibration plot startup
function startCalibRawPlot() {
  if (calibRawInterval) clearInterval(calibRawInterval);
  calibPlotRunning = true;
  pollingMode = 'calibration';
  stopMainDisplayPolling();
  document.getElementById('calib-plot-toggle').textContent = 'Pause';
  calibRawInterval = setInterval(async () => {
    if (!calibPlotRunning) return;
    // Only fetch if main display is not polling
    if (pollingMode !== 'calibration') return;
    const rawVal = await fetchRawSensorValue();
    const parsed = parseFloat(rawVal);
    if (!isNaN(parsed)) {
      calibRawHistory.push(parsed);
      if (calibRawHistory.length > CALIB_RAW_HISTORY_MAX) calibRawHistory.shift();
      document.getElementById('calib-current-raw').textContent = parsed.toFixed(2);
      updateCalibRawPlot();
    }
  }, 200);
}
function updateCalibRawPlot() {
  if (!calibRawPlot) return;
  calibRawPlot.data.labels = calibRawHistory.map((_, i) => i);
  calibRawPlot.data.datasets[0].data = calibRawHistory;
  calibRawPlot.update();
}
function setupCalibRawPlot() {
  const ctx = document.getElementById('calib-raw-plot').getContext('2d');
  calibRawPlot = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Raw',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#FF6384', // Use the same color as the heading
        data: [],
        fill: false,
        pointRadius: 0,
        borderWidth: 2,
      }]
    },
    options: {
      animation: false,
      responsive: false,
      legend: {
        display: true,
        labels: {
          usePointStyle: true,
          boxWidth: 0,
          fontColor: '#fff',
          padding: 12,
          generateLabels: function(chart) {
            // Only show text, no box
            return [{
              text: 'Raw',
              fillStyle: 'rgba(0,0,0,0)',
              strokeStyle: 'rgba(0,0,0,0)',
              lineWidth: 0,
              hidden: false,
              index: 0
            }];
          }
        }
      },
      scales: {
        xAxes: [{ display: false }],
        yAxes: [{ display: true, ticks: { fontSize: 10, fontColor: '#fff' }, gridLines: { color: 'rgba(255,255,255,0.1)' } }]
      },
      elements: { line: { tension: 0 } }
    }
  });
}
document.addEventListener('DOMContentLoaded', function() {
  setupCalibRawPlot();
  // Do NOT startCalibRawPlot() by default
  document.getElementById('calib-plot-toggle').onclick = function() {
    if (calibPlotRunning) stopCalibRawPlot();
    else startCalibRawPlot(); // Only start polling when user presses Resume
  };
  // Set button to Resume by default
  document.getElementById('calib-plot-toggle').textContent = 'Resume';
  // Add Clear button handler
  document.getElementById('calib-plot-clear').onclick = function() {
    calibRawHistory = [];
    if (calibRawPlot) {
      calibRawPlot.data.labels = [];
      calibRawPlot.data.datasets[0].data = [];
      calibRawPlot.update();
    }
    document.getElementById('calib-current-raw').textContent = '---';
  };
});
// Patch readCalibrationRaw to pause/resume plot
const origReadCalibrationRaw = readCalibrationRaw;
readCalibrationRaw = async function(idx, direction) {
  stopCalibRawPlot();
  await origReadCalibrationRaw(idx, direction);
  // After reading, allow user to resume
  setTimeout(() => {
    resumeCalibRawPlot();
  }, 500); // Small delay to avoid overlap
};
</script>

<script>
// Tab switching logic for Calibration Utility
(function() {
  function showTab(tab) {
    document.querySelectorAll('.calib-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById('calib-tab-content-' + tab).style.display = 'block';
    document.querySelectorAll('.calib-tab-btn').forEach(btn => btn.style.background = '#e0e0e0');
    document.querySelector('.calib-tab-btn[data-tab="' + tab + '"]').style.background = '#fff';
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.onclick = function() { showTab(btn.getAttribute('data-tab')); };
    });
    showTab('specs'); // Default tab
  });
})();
// 2-Point Calibration logic (stub, to be implemented)
window.read2ptRaw = async function(idx) {
  const input = document.getElementById('twopt-load' + idx);
  const rawCell = document.getElementById('twopt-raw' + idx);
  const weight = parseFloat(input.value);
  if (isNaN(weight)) { alert('Please enter a known load before reading.'); return; }
  
  // Pause calibration plot if running
  const wasPlotRunning = calibPlotRunning;
  if (wasPlotRunning) {
    stopCalibRawPlot();
  }
  
  rawCell.textContent = 'Averaging...';
  const avgRawValue = await getMovingAverageRawValue(100, 10);
  if (isNaN(avgRawValue)) {
    rawCell.textContent = 'Error';
    alert('Failed to get a valid average raw value.');
    return;
  }
  rawCell.textContent = avgRawValue.toFixed(2);
  input.setAttribute('data-raw', avgRawValue);
  
  // Resume plot if it was running before
  if (wasPlotRunning) {
    setTimeout(() => {
      resumeCalibRawPlot();
    }, 500);
  }
};
window.calculate2ptCalibration = function() {
  const w1 = parseFloat(document.getElementById('twopt-load1').value);
  const w2 = parseFloat(document.getElementById('twopt-load2').value);
  const r1 = parseFloat(document.getElementById('twopt-raw1').textContent);
  const r2 = parseFloat(document.getElementById('twopt-raw2').textContent);
  
  if ([w1, w2, r1, r2].some(x => isNaN(x))) {
    document.getElementById('calibration-result-2pt').textContent = 'Please enter both weights and read both raw values.';
    return;
  }
  
  // Check that the two points are different
  if (w1 === w2) {
    document.getElementById('calibration-result-2pt').textContent = 'Error: The two known loads must be different for 2-point calibration.';
    return;
  }
  
  // Linear fit: raw = slope * weight + intercept
  const slope = (r2 - r1) / (w2 - w1);
  const intercept = r1 - slope * w1;
  
  // Store for use in main display and burning
  window._calibSlope = slope;
  window._calibIntercept = intercept;
  
  document.getElementById('calibration-result-2pt').innerHTML = 
    `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>` +
    `Calibration ready to burn.`;
};
window.burn2ptCalibration = async function() {
  const w1 = parseFloat(document.getElementById('twopt-load1').value);
  const w2 = parseFloat(document.getElementById('twopt-load2').value);
  const r1 = parseFloat(document.getElementById('twopt-raw1').textContent);
  const r2 = parseFloat(document.getElementById('twopt-raw2').textContent);
  
  if ([w1, w2, r1, r2].some(x => isNaN(x))) {
    alert('Please enter both weights and read both raw values before burning calibration.');
    return;
  }
  
  // Check that the two points are different
  if (w1 === w2) {
    alert('Error: The two known loads must be different for 2-point calibration.');
    return;
  }
  
  // Calculate linear fit: raw = slope * weight + intercept
  const slope = (r2 - r1) / (w2 - w1);
  const intercept = r1 - slope * w1;
  
  // For 2-point calibration, we use linear fit (cubic with a=b=0)
  const CCA = 0; // No cubic term
  const CCB = 0; // No quadratic term  
  const CCC = slope; // Linear coefficient
  const CCD = intercept; // Constant term
  const FAZ = r1; // Use first raw value as offset
  
  try {
    // Set NCAL mode to 1 (single direction/compression only for 2-point)
    await writer.write(`ncal 1\r`);
    await delay(500);
    
    // Send the coefficients to the sensor
    await writer.write(`CCA ${CCA}\r`);
    await delay(500);
    await writer.write(`CCB ${CCB}\r`);
    await delay(500);
    await writer.write(`CCC ${CCC}\r`);
    await delay(500);
    await writer.write(`CCD ${CCD}\r`);
    await delay(500);
    await writer.write(`FAZ ${FAZ}\r`);
    await delay(500);
    
    // Update the result display
    document.getElementById('calibration-result-2pt').innerHTML = 
      `2-Point Linear Calibration burned successfully!<br>` +
      `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>` +
      `FAZ = ${FAZ.toFixed(2)}`;
    
    // Store for use in main display
    window._calibSlope = slope;
    window._calibIntercept = intercept;
    
    alert('2-Point calibration burned successfully!');
  } catch (e) {
    alert('Failed to burn 2-point calibration: ' + e);
  }
};
</script>
</body>
</html>

