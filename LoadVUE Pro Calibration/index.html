<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LoadVUE Pro Cloud</title>
<meta name="Description" content="Set your baud speed and hit connect. A serial terminal that runs without any plugins in chrome.">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    * {
        background-color: #ECECEC;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        padding: 0px;
    }
    .horizontal-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 75%;
        color: #000000;
        margin-top: 10px;
    }
    .Header_Title{
        text-align: left;
        background-color: #B2E4FF;
        font-size: xx-large;
    }
    .right {
        text-align: right;
        background-color: #B2E4FF;
    }
    .container2 {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
    }
    .button {
        width: 25%;
        height: 25px; 
        color: #FFFFFF;
    }
    .subheading {
        font-size: 14px; 
        padding-right: 5px; 
    }
    .entrybox {
        font-size: 14px; 
        padding-right: 5px; 
    }
    button,
    datalist {
        background-color: #007BC6;
        border: none; 
        border-bottom: 1px solid #002942;
        border-right: 1px solid #002942;
    }
    input[type=text] { 
        width: 100px;
        color: #000000;
        border: none; 
    }
    [type="checkbox"] {
        vertical-align: middle;
        font-size: 14px;
    }
    #topBanner {
        width: calc(100% - 10px);
        overflow: scroll;
        background-color: #B2E4FF;
        padding: 5px;
        margin: 0px;
    }
    #reading-content {
        display: flex;
    }
    #serialResults {
        white-space: pre;
        height: 30%;
        width: 100%;
        border-style: solid;
        overflow-y: scroll;
        background-color: #000000;
        color: #FFFFFF;
        padding: 10px;
        margin: 0px;
        float: left;
    }
    #right-section {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
        margin-top: -23px;
    }
    #right-section2 {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
    }
    #right-section3 {
        padding-left: 10px;
        padding-right: 10px;
        background-color: #ECECEC;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        width: 25%;
        height: 25vh;
    }
    .value-container {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: left;
        width: 100%;
        text-align: left; 
    }
    .value-label {
        color: #000000;
        font-size: 16px;
        margin-bottom: 5px;
    }
    #peak-value {
        background-color: #000000;
        display: flex;
        justify-content: left;
        padding-left: 10px;
        align-items: center;
        color: #0000FF;
        font-size: 16px;
        width: 100%;
        height: 50px;
    }
    #low-value {
        background-color: #000000; 
        display: flex;
        justify-content: left;
        padding-left: 10px;
        align-items: center;
        color: #FF0000;
        font-size: 16px;
        width: 100%;
        height: 50px; 
    }
    
    #button {
        width: 350px;
        height: 25px; 
        color: #FFFFFF;
    }

    #small-button {
        width: 200px;
        height: 25px; 
        color: #FFFFFF;
    }

    .outputBox {
        width: 100%;
        height: 30vh;
        background-color: #000000;
        border: 1px solid;
        box-sizing: border-box;
        color: #FFFFFF;
        font-size: 120px;
        text-align: right; 
        vertical-align: middle;
    }
    /* New styles for horizontal alignment */
    .horizontal-align {
        display: flex;
    }
    .horizontal-align label {
        margin-right: 10px;
    }
    .horizontal-align select {
        flex-grow: 1;
    }

    /* New styles for button container */
    .button-container {
        justify-content: space-between;
        display: flex;
        width: 74%;
        margin: 0px; /* Center the container */
    }

    /* New styles for the scrollable table */
    #table-container {
        width: 100%;
        height: 345px;
        overflow-y: scroll;
        border: 1px solid #ccc;
        background-color: black;
    }

    #data-table {
        width: 100%;
        border-collapse: collapse;
        background-color: black;
    }

    #data-table th, #data-table td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        background-color: black; 
        color: white; 
    }

    #data-table th {
        background-color: black;
    }
    #dataChart {
    background-color: #000000; /* Set the background color to black */
    width: 100%;
    height: 100%;
}
#calibration-table th, #calibration-table td {
    padding: 2px 2px !important;
    font-size: 15px;
    text-align: center;
}
#calibration-table input[type=number] {
    width: 80px;
    height: 22px;
    font-size: 14px;
    padding: 2px 4px;
    margin: 0;
    text-align: right;
}
#calibration-table button {
    color: white;
    width: 48px;
    height: 22px;
    font-size: 13px;
    padding: 0 4px;
    margin: 0;
}
#calibration-table {
    margin-left: 0;
    table-layout: fixed;
}
/* Stylish Burn button */
.burn-btn {
    background-color: #007BC6;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 4px 16px;
    font-size: 15px;
    margin-left: 6px;
    margin-right: 10px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    transition: background 0.18s, box-shadow 0.18s;
    vertical-align: middle;
}
.burn-btn:hover, .burn-btn:focus {
    background-color: #005b8a;
    box-shadow: 0 4px 12px rgba(0,0,0,0.13);
}
/* Remove previous calibration-section/table overrides, keep original white style */
#calib-live-section > div {
  /* Only style the plot and value area, not the table */
}
    .specs-row {
        display: grid;
        grid-template-columns: 110px 120px 80px;
        align-items: center;
        gap: 10px;
        margin-bottom: 0;
    }
    .specs-label {
        min-width: 110px;
    }
    .specs-input {
        width: 120px !important;
        min-width: 120px;
        max-width: 120px;
        box-sizing: border-box;
        height: 28px;
        padding: 2px 6px;
    }
    .specs-row select.specs-input {
        height: 28px;
        padding: 2px 6px;
    }
    .specs-burn-btn {
        width: 80px;
    }
    #reading-controls-column {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 18px;
      min-width: 200px;
      max-width: 220px;
      padding: 24px 18px 24px 18px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      border: 1px solid #e0e0e0;
      margin-top: 0;
      margin-bottom: 0;
      height: fit-content;
    }
    #reading-controls-column .horizontal-align {
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      margin-bottom: 0;
      background: none !important;
    }
    #reading-controls-column label.value-label {
      min-width: 70px;
      font-size: 15px;
      color: #222;
      margin-right: 8px;
      text-align: left;
      background: none !important;
    }
    #reading-controls-column select {
      width: 90px;
      height: 28px;
      font-size: 15px;
      border-radius: 4px;
      border: 1px solid #bbb;
      background: #fff;
      color: #222;
      padding-left: 6px;
    }
    #reading-controls-column #peak-value,
    #reading-controls-column #low-value {
      width: 90px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      margin-left: 0;
      margin-top: 0;
      border-radius: 4px;
      border: 1px solid #bbb;
      background: #000;
    }
    /* Tab Bar: Calibration Utility Tabs */
    .calib-tab-btn {
      padding: 8px 18px;
      border-radius: 6px 6px 0 0;
      border: none;
      background: #007BC6;
      color: #fff;
      font-weight: bold;
      transition: background 0.18s, color 0.18s;
    }
    .calib-tab-btn.active-tab {
      background: #fff;
      color: #007BC6;
    }
</style>
</head>
<body>
<div class="horizontal-container" id="topBanner"> 
    <label class="Header_Title" for="ProductName">LoadVUE Pro Cloud - Calibration App</label>
    <button id="connect" onclick="connectSerial()" style="margin-right: 98px;height: 36px;font-size: 18px;" class="button">Connect Serial Port</button>
    <button id="disconnect" style="display: none;margin-right: 98px;height: 36px;font-size: 18px;" onclick="disconnectSerial()" class="button">Disconnect</button>
    <img class="right" src="images/loadstar_sensors_logo.png">
</div>

<!-- Calibration Utility always visible -->
<div id="calibration-section" style="width: 100%; background: none; padding: 0; border-radius: 0; max-width: 100%; min-width: 0; margin: 0; position: relative;">
  <div id="calibration-modal-body">
    <h2 style="margin-bottom: 10px;">Calibration Utility</h2>
    <!-- Tab Bar: Add Verify Calibration as fourth tab -->
    <div id="calib-tabs" style="display: flex; gap: 8px; margin-bottom: 18px;">
      <button class="calib-tab-btn" data-tab="specs">Specifications</button>
      <button class="calib-tab-btn" data-tab="mvv">mV/V Calibration</button>
      <button class="calib-tab-btn" data-tab="2pt">2-Point Calibration</button>
      <button class="calib-tab-btn" data-tab="multi">Multi-Point Calibration</button>
      <button class="calib-tab-btn" data-tab="verify">Verify Calibration</button>
      <button class="calib-tab-btn" data-tab="data">Data</button>
    </div>
    <!-- Tab Contents -->
    <div id="calib-tab-content-specs" class="calib-tab-content">
      <!-- Specifications Tab Content -->
      <div style="display: flex; flex-direction: column; gap: 16px; max-width: 280px; margin-bottom: 10px;">
        <div class="specs-row">
          <label for="sensorID" class="specs-label">ID:</label>
          <input type="text" class="entrybox specs-input" id="sensorID" style="border: 1.5px solid #888; background: #fff;">
          <button onclick="burnID()" class="burn-btn specs-burn-btn">Burn</button>
        </div>
        <div class="specs-row">
          <label for="sensorCapacity" class="specs-label">Capacity:</label>
          <input type="text" class="entrybox specs-input" id="sensorCapacity" style="border: 1.5px solid #888; background: #fff;">
          <button onclick="burnCapacity()" class="burn-btn specs-burn-btn">Burn</button>
        </div>
        <div class="specs-row">
          <label for="sensorUnits" class="specs-label">Units:</label>
          <select id="sensorUnits" class="specs-input" onchange="burnUnits()" style="border: 1.5px solid #888; background: #fff;">
            <option value="lb">lb</option>
            <option value="kg">kg</option>
            <option value="g">g</option>
            <option value="N">N</option>
          </select>
          <button onclick="burnUnits()" class="burn-btn specs-burn-btn">Burn</button>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="ncal-mode" style="min-width: 110px;">Calibration Mode:</label>
          <select id="ncal-mode" onchange="setNCALMode()" style="border: 1.5px solid #888; background: #fff; flex: 1;">
            <option value="1">Compression Only</option>
            <option value="2">Compression/Tension</option>
          </select>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="baud" style="min-width: 110px;">Baud Rate:</label>
          <select id="baud" style="border: 1.5px solid #888; background: #fff; flex: 1;">
            <option value="9600" selected>9600</option>
            <option value="203400">203400 (High Speed)</option>
          </select>
        </div>
      </div>
      <div id="specs-summary" style="margin-top: 10px; font-size: 15px; color: #333;"></div>
    </div>
    <!-- mV/V Calibration Tab Content -->
    <div id="calib-tab-content-mvv" class="calib-tab-content" style="display:none;">
      <div style="display: flex; flex-direction: column; gap: 16px; max-width: 340px; margin-bottom: 10px;">
        <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">mV/V Calibration</div>
        <div style="font-size: 15px; margin-bottom: 8px;">Enter the mV/V value provided by the manufacturer (usually on the spec sheet or sensor label) and click <em>Burn mV/V</em>.</div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="mvv-value" style="min-width: 110px; font-size: 15px;">mV/V Value:</label>
          <input type="number" step="0.0001" min="0" class="entrybox specs-input" id="mvv-value" style="border: 1.5px solid #888; background: #fff; width: 120px;" placeholder="e.g. 2.0000">
          <button onclick="burnMVV()" class="burn-btn specs-burn-btn" id="burn-mvv-btn" style="background: #d9534f; color: #fff; min-height: 40px; min-width: 240px; font-size: 20px;">Burn mV/V Calibration</button>
        </div>
        <div id="mvv-burn-result" style="margin-top: 8px; font-size: 15px; color: #007BC6;"></div>
      </div>
    </div>
    <div id="calib-tab-content-2pt" class="calib-tab-content" style="display:none;">
      <!-- 2-Point Calibration Tab Content -->
      <div style="margin-bottom: 30px;">
        <strong>2-Point Calibration Instructions:</strong><br><br>
        1. Enter two different known loads (e.g., 0 and 100)<br>
        2. Click "Capture" for each load to capture the raw sensor values<br>
        3. Click "Calculate Calibration" to see the linear fit<br>
        4. Click "Burn Calibration" to save to sensor<br>
        5. Click "Verify Calibration" to verify the calibration
      </div>
      <div style="display: flex; flex-direction: column; align-items: flex-start; width: 100%; max-width: 480px; margin: 0 auto 0 0; padding: 0;">
        <table id="twopt-calibration-table" style="width: 100%; border-collapse: collapse; background-color: #007BC6; table-layout: fixed; margin-bottom: 12px; border-radius: 0; box-shadow: none;">
          <thead>
            <tr style="background: #007BC6; color: #000; border-radius: 0; font-weight: bold;">
              <th style="width: 30px; text-align: center; border-radius: 0;">#</th>
              <th style="width: 120px; text-align: center; border-radius: 0; font-weight: bold;">Known Load</th>
              <th style="width: 120px; text-align: center; border-radius: 0; font-weight: bold;">Raw Value</th>
              <th style="width: 90px; text-align: center; border-radius: 0; font-weight: bold;">Action</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center;">1</td>
              <td style="text-align: center;">
                <input type="number" id="twopt-load1" style="width: 100px; height: 28px; font-size: 15px; text-align: center; border: 1.5px solid #888; border-radius: 0; background: #fff; margin: 0 auto;" placeholder="Enter">
              </td>
              <td id="twopt-raw1" style="text-align: center;">---</td>
              <td style="text-align: center;">
                <button onclick="read2ptRaw(1)" class="burn-btn" style="border-radius: 0;">Capture</button>
              </td>
            </tr>
            <tr>
              <td style="text-align: center;">2</td>
              <td style="text-align: center;">
                <input type="number" id="twopt-load2" style="width: 100px; height: 28px; font-size: 15px; text-align: center; border: 1.5px solid #888; border-radius: 0; background: #fff; margin: 0 auto;" placeholder="Enter">
              </td>
              <td id="twopt-raw2" style="text-align: center;">---</td>
              <td style="text-align: center;">
                <button onclick="read2ptRaw(2)" class="burn-btn" style="border-radius: 0;">Capture</button>
              </td>
            </tr>
          </tbody>
        </table>
        <div style="display: flex; flex-direction: row; justify-content: center; gap: 12px; width: 100%; margin-top: 20px;">
          <button onclick="calculate2ptCalibration()" class="burn-btn" style="height: 40px; min-width: 160px; font-size: 20px; background: #007BC6; color: #fff; border-radius: 6px; border: none;">Calculate Calibration</button>
          <button onclick="burn2ptCalibration()" class="burn-btn" style="height: 40px; min-width: 160px; font-size: 20px; background: #d9534f; color: #fff; border-radius: 6px; border: none;">Burn Calibration</button>
        </div>
      </div>
      <div id="calibration-result-2pt" style="margin-top: 12px; font-size: 15px;"></div>
    </div>
    <div id="calib-tab-content-multi" class="calib-tab-content" style="display:none; padding-bottom: 60px;">
      <!-- Multi-Point Calibration Tab Content (with both directions) -->
      <div id="calib-live-section" style="width: 100%; max-width: 100vw; margin-bottom: 18px; display: flex; flex-direction: column; align-items: center;">
        <div style="display: flex; flex-direction: row; width: 100%; gap: 0;">
          <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #000; border-radius: 8px 0 0 8px; min-width: 0;">
            <div style="font-size: 32px; color: #FF6384; margin-bottom: 12px; margin-top: 24px; background: #000;">Current Raw Value</div>
            <div id="calib-current-raw" style="width: 100%; height: 180px; background: #000; color: #fff; font-size: 64px; display: flex; align-items: center; justify-content: center; border-radius: 0; border: none; font-family: 'Segoe UI', monospace;">---</div>
          </div>
          <div style="flex: 2; display: flex; flex-direction: column; align-items: center; background: #000; border-radius: 0 8px 8px 0; min-width: 0;">
            <div style="font-size: 32px; color: #FF6384; margin-bottom: 12px; margin-top: 24px; background: #000;">Raw Value Plot</div>
            <canvas id="calib-raw-plot" width="900" height="240" style="background: #000; border-radius: 0; border: none; width: 100%; max-width: 100%;"></canvas>
          </div>
        </div>
        <div style="width: 100%; display: flex; justify-content: center; margin-top: 18px;">
          <button id="calib-plot-toggle" class="burn-btn" style="height: 40px; min-width: 160px; font-size: 20px; background: #007BC6; color: #fff; border-radius: 6px; border: none;">Start</button>
          <button id="calib-plot-clear" class="burn-btn" style="height: 40px; min-width: 160px; font-size: 20px; background: #d9534f; color: #fff; border-radius: 6px; border: none; margin-left: 12px;">Clear</button>
        </div>
      </div>
      <table id="calibration-table" style="width: 100%; border-collapse: collapse; background-color: #fff; margin-left: 0; table-layout: fixed;">
        <thead>
          <tr>
            <th colspan="4" style="text-align: center; background: #007BC6; color: #fff;">Compression</th>
            <th colspan="4" style="text-align: center; background: #007BC6; color: #fff;">Tension</th>
          </tr>
          <tr>
            <th style="width: 30px; text-align: center;">#</th>
            <th style="width: 100px; text-align: center;">Known Load</th>
            <th style="width: 100px; text-align: center;">Raw</th>
            <th style="width: 70px; text-align: center;"></th>
            <th style="width: 30px; text-align: center;">#</th>
            <th style="width: 100px; text-align: center;">Known Load</th>
            <th style="width: 100px; text-align: center;">Raw</th>
            <th style="width: 70px; text-align: center;"></th>
          </tr>
        </thead>
        <tbody id="calibration-table-body">
          <!-- Dynamic rows will be rendered here -->
        </tbody>
      </table>
      <div style="margin-top: 30px; display: flex; justify-content: center; gap: 20px;">
        <button onclick="calculateCalibration()" style="height: 40px; min-width: 240px; font-size: 20px; background: #007BC6; color: #fff; border-radius: 12px; border: none;">Calculate Calibration</button>
        <button onclick="burnCalibration()" style="height: 40px; min-width: 240px; font-size: 20px; background: #d9534f; color: #fff; border-radius: 12px; border: none;">Burn Calibration</button>
      </div>
      <div id="calibration-result" style="margin-top: 8px; font-size: 15px;"></div>
    </div>
    <!-- Verify Calibration Tab Content (hidden by default) -->
    <div id="calib-tab-content-verify" class="calib-tab-content" style="display:none;">
      <!-- Calibration Status Display -->
      <div style="margin-bottom: 10px;">
        <button id="refresh-calib-status-btn" style="padding: 6px 18px; font-size: 15px; background: #007BC6; color: #fff; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 10px;">Refresh Calibration Status</button>
      </div>
      <div id="calibration-status" style="margin-bottom: 20px;"></div>
      
      <div id="middle" style="margin-top:10px;">
        <div id="reading-content" style="display: flex; flex-direction: row; align-items: flex-start; gap: 32px;">
          <div id="outputReading" class="outputBox"></div>
          <!-- Controls column -->
          <div id="reading-controls-column" style="display: flex; flex-direction: column; align-items: flex-start; gap: 18px; min-width: 200px; max-width: 220px; padding: 24px 18px 24px 18px; background: #f7f7f7; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.04); border: 1px solid #e0e0e0; margin-top: 0; margin-bottom: 0; height: fit-content;">
            <div class="horizontal-align" style="width: 100%; display: flex; flex-direction: row; align-items: center; gap: 8px; margin-bottom: 0;">
              <label class="value-label" style="min-width: 70px; font-size: 15px; color: #222; margin-right: 8px; text-align: left;">Resolution:</label>
              <select id="resolutionSelect" onchange="return updateResolution()" style="width: 90px; height: 28px; font-size: 15px; border-radius: 4px; border: 1px solid #bbb; background: #fff; color: #222; padding-left: 6px;">
                <option value="0">x</option>
                <option value="1">x.x</option>
                <option value="2" selected>x.xx</option>
              </select>
            </div>
            <div class="horizontal-align" style="width: 100%; display: flex; flex-direction: row; align-items: center; gap: 8px; margin-bottom: 0;">
              <label class="value-label" style="min-width: 70px; font-size: 15px; color: #222; margin-right: 8px; text-align: left;">Units:</label>
              <select id="unitSelect" onchange="updateUnits()" style="width: 90px; height: 28px; font-size: 15px; border-radius: 4px; border: 1px solid #bbb; background: #fff; color: #222; padding-left: 6px;">
                <option value="lb">lb</option>
                <option value="kg">kg</option>
                <option value="g">g</option>
                <option value="N">N</option>
              </select>
            </div>
            <div class="horizontal-align" style="width: 100%; display: flex; flex-direction: row; align-items: center; gap: 8px; margin-bottom: 0;">
              <label class="value-label" style="min-width: 70px; font-size: 15px; color: #222; margin-right: 8px; text-align: left;">Average:</label>
              <select id="averageReading" onchange="averageReading()" style="width: 90px; height: 28px; font-size: 15px; border-radius: 4px; border: 1px solid #bbb; background: #fff; color: #222; padding-left: 6px;">
                <option value="1">1</option>
                <option value="10">10</option>
                <option value="50">50</option>
                <option value="100">100</option>
              </select>
            </div>
            <div class="horizontal-align" style="width: 100%; display: flex; flex-direction: row; align-items: center; gap: 8px; margin-bottom: 0; background: none !important;">
              <div class="value-label" style="min-width: 70px; font-size: 15px; color: #222; margin-right: 8px; text-align: left; background: none !important;">Peak:</div>
              <div id="peak-value" style="background-color: #000000; color: #0000FF; font-size: 16px; width: 90px; height: 32px; display: flex; align-items: center; justify-content: center; margin-left: 0; margin-top: 0; border-radius: 4px; border: 1px solid #bbb;">N/A</div>
            </div>
            <div class="horizontal-align" style="width: 100%; display: flex; flex-direction: row; align-items: center; gap: 8px; margin-bottom: 0; background: none !important;">
              <div class="value-label" style="min-width: 70px; font-size: 15px; color: #222; margin-right: 8px; text-align: left; background: none !important;">Low:</div>
              <div id="low-value" style="background-color: #000000; color: #FF0000; font-size: 16px; width: 90px; height: 32px; display: flex; align-items: center; justify-content: center; margin-left: 0; margin-top: 0; border-radius: 4px; border: 1px solid #bbb;">N/A</div>
            </div>
          </div>
        </div>
      </div>
      <div class="button-container" style="width: 100%; display: flex; justify-content: center; align-items: center; margin-top: 5px; gap: 16px;">
        <button id="tare" onclick="tare()" style="color:white; min-width: 160px; height: 32px; display: none; border-radius: 12px;">Tare</button>
        <button id="read" onclick="showReading()" style="color:white; min-width: 160px; height: 32px; display: none; border-radius: 12px;">Read</button>
        <button id="stop" onclick="stopReading()" style="color:white; min-width: 160px; height: 32px; display: none; border-radius: 12px;">Stop</button>
      </div>
      <div style="margin-top:10px; margin-bottom: 10px; font-size: 14; font-weight: bold;">
        Force vs Time Plot:&nbsp;<span id="graphtype" style="text-transform: capitalize;"></span></div>
      <div style="width: 100vw; max-width: 100vw; margin-left: calc(-50vw + 50%);">
        <div id="graph-container" style="width: 100vw; max-width: 100vw; height: 40vh;">
          <canvas id="dataChart" style="width: 100vw; max-width: 100vw; height: 40vh;"></canvas>
        </div>
        <div id="chart-controls-row" style="width: 100%; display: flex; flex-direction: row; gap: 16px; justify-content: center; align-items: center; margin-top: 10px;">
          <button onclick="showCumulativeGraph()" style="color:white; min-width: 160px; height: 32px; border-radius: 12px;">Cumulative</button>
          <button onclick="showRecentGraph()" style="color:white; min-width: 160px; height: 32px; border-radius: 12px;">Strip Chart</button>
        </div>
      </div>
    </div>
    <!-- Data Tab Content (hidden by default) -->
    <div id="calib-tab-content-data" class="calib-tab-content" style="display:none;">
      <div style="margin-top:20px; margin-bottom: 10px; font-size: 24px; font-weight: bold;">Log Data</div>
      <div style="display: flex; width: 100%;">
        <div id="table-container" style="width: 100%; font-size: 12px;">
          <table id="data-table">
            <tbody>
              <!-- Data rows will be dynamically added here -->
            </tbody>
          </table>
        </div>
      </div>
      <div id="save-data-row" style="display: flex; flex-direction: row; justify-content: center; width: 100%; margin-bottom: 6px; margin-top: 6px;">
        <button onclick="saveData()" style="color:white; width: 160px; height: 28px; border-radius: 12px;">Save Data</button>
      </div>
    </div>
  </div>
</div>

<!-- Tab switching logic for Calibration Utility (now with Verify Calibration) -->
<script>
(function() {
  function showTab(tab) {
    document.querySelectorAll('.calib-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById('calib-tab-content-' + tab).style.display = 'block';
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.classList.remove('active-tab');
    });
    document.querySelector('.calib-tab-btn[data-tab="' + tab + '"]').classList.add('active-tab');
    // If switching to verify, (re)initialize chart if needed and start calibration monitoring
    if(tab === 'verify') {
      if(window.chart && window.chart.data) {
        window.chart.update();
      } else if(typeof initializeChart === 'function') {
        initializeChart();
      }
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
      document.getElementById("graphtype").textContent = window.chartMode === 'cumulative'? 'Cumulative': 'Strip Chart';
      // Start calibration monitoring if connected
      if (port && writer && globalReader) {
        startCalibrationMonitoring();
      }
    }
    // If switching to data, ensure table head is present
    if(tab === 'data') {
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
    }
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.onclick = function() { showTab(btn.getAttribute('data-tab')); };
    });
    showTab('specs'); // Default tab
  });
})();
</script>

<script>
    console.log = function() {}
    var port, textEncoder, writableStreamClosed, writer, historyIndex = -1;
    const lineHistory = [];
    const sensorData = [];
    const timestamps = [];
    let readingInterval = null;  // To manage the live reading update interval
    let peakValue = Number.NEGATIVE_INFINITY;  // Initialize as number
    let lowValue = Number.POSITIVE_INFINITY;   // Initialize as number

    let currentUnit = "lb";  // Default unit
    let currentResolution = 2;  // Default resolution (x.xx)
    const conversionFactors = {
        lb: { lb: 1, kg: 0.453592, g: 453.592, N: 4.44822 },
        kg: { lb: 2.20462, kg: 1, g: 1000, N: 9.81 },
        g: { lb: 453.59, kg: 0.001, g: 1, N: 0.0098 },
        N: { lb: 0.22480, kg: 0.10197, g: 101.972, N: 1 }
    };  // Conversion factors
 
    // Global reader for consistent stream management
    var globalReader ;

    // Add calibration settings monitoring
    let calibrationSettingsInterval = null;
    let currentCalibrationSettings = {
        ncalMode: null,
        CCA: null,
        CCB: null,
        CCC: null,
        CCD: null,
        FAZ: null,
        mvv: null
    };

    // Function to fetch calibration settings from sensor
    async function fetchCalibrationSettings() {
        if (!writer || !globalReader) return null;
        
        try {
            const settings = {};
            
            // Fetch NCAL mode
            await writer.write('ncal?\r');
            await delay(100);
            let result = '';
            const decoder = new TextDecoder();
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.ncalMode = parseInt(result.trim()) || null;
            
            // Fetch CCA
            await writer.write('CCA?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.CCA = parseFloat(result.trim()) || null;
            
            // Fetch CCB
            await writer.write('CCB?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.CCB = parseFloat(result.trim()) || null;
            
            // Fetch CCC
            await writer.write('CCC?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.CCC = parseFloat(result.trim()) || null;
            
            // Fetch CCD
            await writer.write('CCD?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.CCD = parseFloat(result.trim()) || null;
            
            // Fetch FAZ
            await writer.write('FAZ?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.FAZ = parseFloat(result.trim()) || null;
            
            // Fetch mV/V
            await writer.write('mvv?\r');
            await delay(100);
            result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) break;
                result += decoder.decode(value);
                if (result.includes('\n')) break;
            }
            settings.mvv = parseFloat(result.trim()) || null;
            
            return settings;
        } catch (error) {
            console.error('Error fetching calibration settings:', error);
            return null;
        }
    }

    // Function to update calibration status display
    function updateCalibrationStatus(settings) {
        const statusDiv = document.getElementById('calibration-status');
        if (!statusDiv) return;
        
        if (!settings) {
            statusDiv.innerHTML = '<div style="color: #d9534f; font-weight: bold;">Calibration Status: No calibration detected</div>';
            return;
        }
        
        let statusHTML = '<div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007BC6;">';
        statusHTML += '<div style="font-weight: bold; color: #007BC6; margin-bottom: 8px;">Current Calibration Settings:</div>';
        
        // Determine calibration type
        let calibrationType = 'Unknown';
        if (settings.CCA !== null && settings.CCA !== 0) {
            calibrationType = 'Cubic (Multi-Point)';
        } else if (settings.CCC !== null && settings.CCC !== 0) {
            calibrationType = 'Linear (2-Point)';
        } else if (settings.mvv !== null) {
            calibrationType = 'mV/V Only';
        }
        
        statusHTML += `<div><strong>Type:</strong> ${calibrationType}</div>`;
        statusHTML += `<div><strong>NCAL Mode:</strong> ${settings.ncalMode === 1 ? 'Compression Only' : settings.ncalMode === 2 ? 'Compression/Tension' : 'Unknown'}</div>`;
        
        if (settings.CCA !== null) statusHTML += `<div><strong>CCA:</strong> ${settings.CCA.toExponential(6)}</div>`;
        if (settings.CCB !== null) statusHTML += `<div><strong>CCB:</strong> ${settings.CCB.toExponential(6)}</div>`;
        if (settings.CCC !== null) statusHTML += `<div><strong>CCC:</strong> ${settings.CCC.toExponential(6)}</div>`;
        if (settings.CCD !== null) statusHTML += `<div><strong>CCD:</strong> ${settings.CCD.toExponential(6)}</div>`;
        if (settings.FAZ !== null) statusHTML += `<div><strong>FAZ:</strong> ${settings.FAZ.toFixed(2)}</div>`;
        if (settings.mvv !== null) statusHTML += `<div><strong>mV/V:</strong> ${settings.mvv.toFixed(4)}</div>`;
        
        statusHTML += '</div>';
        statusDiv.innerHTML = statusHTML;
    }

    // Function to start monitoring calibration settings
    function startCalibrationMonitoring() {
        fetchCalibrationSettings().then(settings => {
            currentCalibrationSettings = settings || {};
            updateCalibrationStatus(settings);
        });
    }

    async function connectSerial() {
        
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: parseInt(document.getElementById("baud").value) });
            
            let settings = {};
            if (localStorage.dtrOn == "true") settings.dataTerminalReady = true;
            if (localStorage.rtsOn == "true") settings.requestToSend = true;
            if (Object.keys(settings).length > 0) await port.setSignals(settings);
  
            textEncoder = new TextEncoderStream();
            writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
            writer = textEncoder.writable.getWriter();

            // Create a global reader for managing the stream
            if (!globalReader) {
                globalReader = port.readable.getReader();
            }

            // Fetch and display sensor capacity after connecting
            const capacityValue = await fetchSensorCapacity();
            document.getElementById("sensorCapacity").value = capacityValue;

            // Fetch and display sensor ID after connecting
            const sensorID = await fetchSensorID();
            document.getElementById("sensorID").value = sensorID;

            // Fetch and display sensor units after connecting
            const sensorUnits = await fetchSensorUnits();
            // Normalize and set sensorUnits dropdown
            if (sensorUnits) {
                let normalized = sensorUnits.trim();
                if (normalized.toLowerCase() === 'n') normalized = 'N';
                if (["lb", "kg", "g", "N"].includes(normalized)) {
                    document.getElementById("sensorUnits").value = normalized;
                } else {
                    document.getElementById("sensorUnits").value = "lb";
                }
            }

            // Start monitoring calibration settings
            startCalibrationMonitoring();

        document.getElementById("connect").style.display = "none";
        document.getElementById("disconnect").style.display = "block";
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "block";
        document.getElementById("tare").style.display = "block";
        } catch (e){
        document.getElementById("connect").style.display = "block";
        document.getElementById("disconnect").style.display = "none";
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "none";
        document.getElementById("tare").style.display = "none";
            alert("Serial Connection Failed: " + e);
        }
    }

    async function disconnectSerial() {
        if (port) {
            try {
                document.getElementById("disconnect").textContent ='disconnecting please wait...';
                document.getElementById("disconnect").disabled = true;
                
                // Stop monitoring calibration settings
                stopCalibrationMonitoring();
                
                if (writer) {
                    await writer.close();
                    await writableStreamClosed;
                }
                if (globalReader) {
                    await globalReader.cancel();
                    globalReader.releaseLock();
                    globalReader = null;
                }
                await port.close();
                alert("Serial Connection Closed Successfully");
                window.location.reload();
            } catch (e) {
                alert("Failed to close serial connection: " + e);
            } finally {
                port = null;
                writer = null;
                textEncoder = null;
                document.getElementById("disconnect").textContent ='Disconnect';
                document.getElementById("disconnect").disabled = false;
                document.getElementById("connect").style.display = "block";
                document.getElementById("disconnect").style.display = "none";
                document.getElementById("stop").style.display = "none";
                document.getElementById("read").style.display = "none";
                document.getElementById("tare").style.display = "none";
                clearInterval(readingInterval);  // Stop live reading updates
                document.getElementById("sensorID").value = "";
                document.getElementById("sensorCapacity").value = "";
                document.getElementById("sensorUnits").value = "";
            }
        } else {
            alert("No serial connection to close");
        }
    }

    async function fetchSensorCapacity() {
        const command = 'slc\r';  // Command to request sensor capacity
        try {
            let result = '';
            console.log('Sending capacity request command:', command);

            // Send the capacity command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            console.log('Reading capacity from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the capacity to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received capacity:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading capacity:', error);
            return "Error retrieving capacity";
        }
    }

    async function fetchSensorID() {
        const command = 'ss1\r';  // Command to request sensor ID
        try {
            console.log('Sending ID request command:', command);

            // Send the ID command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading ID from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                // console.log('Received chunk:', value);
                // console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the ID to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            // console.log('Final received ID:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading ID:', error);
            return "Error retrieving ID";
        }
    }

    async function tareCmd() {
        const command = 'ct0\r';
        try {
            await writer.write(command);
            console.log('Command:%s sent successfully.',command);
            const decoder = new TextDecoder();
            let result = '';
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read for Tare.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Tare Received chunk:', value);
                console.log('Tare Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the units to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }
        } catch (error) {
            console.error('error in tare command:%O', error)
        }
    }
    async function fetchSensorUnits() {
        const command = 'unit\r';  // Command to request sensor units, assuming 'unit' is the command for units
        try {
            console.log('Sending units request command:', command);

            // Send the units command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading units from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the units to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received units:', result);
            return result.trim();
        } catch (error) {
            console.error('Error reading units:', error);
            return "Error retrieving units";
        }
    }

    async function fetchSensorData() {
        const command = 'o0w1\r';  // Command to request sensor data
        try {
            console.log('Sending data request command:', command);

            // Send the data command to the sensor
            await writer.write(command);
            console.log('Command sent successfully.');

            const decoder = new TextDecoder();
            let result = '';
            console.log('Reading data from sensor...');
            
            while (true) {
                const { value, done } = await globalReader.read();
                if (done) {
                    console.log('No more data to read.');
                    break;
                }

                // Append the received value to the result
                result += decoder.decode(value);
                console.log('Received chunk:', value);
                console.log('Decoded chunk:', decoder.decode(value));
                
                // Break early if we expect the data to end with a specific character
                if (result.includes('\n')) {
                    console.log('End of data detected.');
                    break;
                }
            }

            console.log('Final received data:', result);
            return parseFloat(result.trim()).toFixed(2);
        } catch (error) {
            console.error('Error reading data:', error);
            return "Error retrieving data";
        }
    }

    async function showCapacityNew() {
        const capacityValue = await fetchSensorCapacity();
        document.getElementById("outputCapacity").textContent = `Capacity: ${capacityValue}`;
    }
function stopReading() {
    isStart = false;
        if (readingInterval) {
            clearInterval(readingInterval);  // Clear any existing interval
        }
        // disable the stop button and enable read and tare buttons
        document.getElementById("stop").style.display = "none";
        document.getElementById("read").style.display = "block";
        // document.getElementById("tare").style.display = "block";
    }
    let isStart = false;
    let avgCount = 1;
    async function showReading() {
        if (pollingMode === 'calibration') {
            alert('Stop the calibration plot to resume main display reading.');
            return;
        }
        if (readingInterval) {
            clearInterval(readingInterval);  // Clear any existing interval
        }
        document.getElementById("stop").style.display = "block";
        document.getElementById("read").style.display = "none";
        isStart = true;
        let sum =0, avg=0,isPush=false, counter=0;
        readingInterval = setInterval(async () => {
            const { weight, deviceUnit } = await fetchDeviceWeightAndUnit();
            let displayValue, convertedData;
            let fromUnit = deviceUnit;
            let toUnit = _currentUnit;
            let value = weight;
            // Convert if needed
            if (fromUnit !== toUnit && conversionFactors[fromUnit] && conversionFactors[fromUnit][toUnit]) {
                value = weight * conversionFactors[fromUnit][toUnit];
            }
            convertedData = value;
            displayValue = `${value.toFixed(currentResolution)} ${toUnit}`;
            if(counter<avgCount) {
                isPush = false;
                sum+=parseFloat(convertedData);
                counter++;
            } else {
                avg = sum/avgCount;
                sum=0;
                counter=0;
                isPush=true;
            }
            const _convertedData = avg.toFixed(currentResolution);
            const now = new Date().toLocaleTimeString();
            if(isPush){
                document.getElementById("outputReading").textContent = displayValue;
                chartData.push(_convertedData);
                chartLabels.push(now);
                addToTable(now, `${_convertedData}`);
                if (chartMode === 'cumulative') {
                    showCumulativeGraph();
                } else if (chartMode === 'recent') {
                    showRecentGraph();
                }
                // Ensure peakValue and lowValue are numbers
                if (typeof convertedData === 'string') convertedData = parseFloat(convertedData);
                if (convertedData > peakValue || !isFinite(peakValue)) {
                    peakValue = convertedData;
                    document.getElementById("peak-value").textContent = isFinite(peakValue) ? peakValue.toFixed(currentResolution) : "N/A";
                }
                if (convertedData < lowValue || !isFinite(lowValue)) {
                    lowValue = convertedData;
                    document.getElementById("low-value").textContent = isFinite(lowValue) ? lowValue.toFixed(currentResolution) : "N/A";
                }
            }
        }, 100);
    }

    async function tare() {
        stopReading()
        if(chartData.length) {
        clearTable();
        chartLabels = []
        chartData = []
        showCumulativeGraph()
        }        
        // Reset current reading to zero
        document.getElementById("outputReading").textContent = `0.00 ${_currentUnit}`;

        // Reset peak and low values to N/A
        peakValue = Number.NEGATIVE_INFINITY;
        lowValue = Number.POSITIVE_INFINITY;
        document.getElementById("peak-value").textContent = `N/A`;
        document.getElementById("low-value").textContent = `N/A`;
        await tareCmd();
    }
var _currentUnit = currentUnit;
    function updateUnits() {
    if(document.getElementById("unitSelect").value!=_currentUnit)
    {
    if(confirm("Unit changes in mid of reading, may clear all prev readings. do you want to clear all prev data?"))
    {
        stopReading();
    }
    }
        _currentUnit = document.getElementById("unitSelect").value;
  removeTableHead();
        createTableHead();
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  const table = tableBody.parentElement; // Get the table element
  table.insertBefore(createTableHead(), tableBody); // Insert the table head before the table body
        console.log('Units changed to:', currentUnit);
    }
    function averageReading() {
        /*
        if(isStart)
        {
            alert("Average changes in mid of reading is not allowed. Please stop reading, change average and start again");
            
            return false;
        } 
            */
            avgCount = parseInt(document.getElementById("averageReading").value);
    }
    function updateResolution() {
        if(isStart)
        {
            alert("Resolution changes in mid of reading is not allowed. Please stop reading, change resolution and start again");
            document.getElementById("resolutionSelect").value = currentResolution;
            return false;
        }
        currentResolution = parseInt(document.getElementById("resolutionSelect").value);
        console.log('Resolution changed to:', currentResolution);
        return true;
    }

    function convertUnits(value) {
        const _conversionFactors = conversionFactors[currentUnit];
        console.log('selected unit conversion units:',_conversionFactors);
        return (value * _conversionFactors[_currentUnit]).toFixed(currentResolution);
    }

function clearTable() {
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  // Using a while loop (more explicit)
  while (tableBody.firstChild) {
    tableBody.removeChild(tableBody.firstChild); 
  }
}
    // Function to add a row to the table
    function addToTable(time, reading) {
        const tableBody = document.querySelector("#data-table tbody");
        const newRow = document.createElement("tr");

        const timeCell = document.createElement("td");
        timeCell.textContent = time;
        timeCell.style.backgroundColor = "#000000"; // Set background color to black
        timeCell.style.color = "#ffffff"; // Set text color to white
        newRow.appendChild(timeCell);

        const readingCell = document.createElement("td");
        readingCell.textContent = reading;
        readingCell.style.backgroundColor = "#000000"; // Set background color to black
        readingCell.style.color = "#ffffff"; // Set text color to white
        newRow.appendChild(readingCell);


    const peakCell = document.createElement("td");
    peakCell.textContent = isFinite(peakValue) ? peakValue.toFixed(currentResolution) : "N/A"; // Display the current peak value
    peakCell.style.backgroundColor = "#000000"; // Set background color to black
    peakCell.style.color = "#ffffff"; // Set text color to white
    newRow.appendChild(peakCell);

    const lowCell = document.createElement("td");
    lowCell.textContent = isFinite(lowValue) ? lowValue.toFixed(currentResolution) : "N/A"; // Display the current low value
    lowCell.style.backgroundColor = "#000000"; // Set background color to black
    lowCell.style.color = "#ffffff"; // Set text color to white
    newRow.appendChild(lowCell);

        tableBody.prepend(newRow);
    }

    function saveData() {
    // Gather necessary information
    const sensorID = document.getElementById("sensorID").value;
    const sensorCapacity = document.getElementById("sensorCapacity").value;
    const sensorUnits = document.getElementById("sensorUnits").value;
    const testDate = new Date().toLocaleDateString();  // Format the date as needed

    // CSV file content
    let csvContent = `Data Log\n`;
    csvContent += `ID: ${sensorID}\n`;
    csvContent += `Capacity: ${sensorCapacity}\n`;
    csvContent += `Units: ${sensorUnits}\n`;
    csvContent += `Test Date: ${testDate}\n\n`;

    // Add table headers
    csvContent += `Time,Reading,Peak,Low\n`;

    // Loop through the table and add the data to the CSV
    const tableRows = document.querySelectorAll("#data-table tbody tr");
    tableRows.forEach(row => {
        const cells = row.querySelectorAll("td");
        const rowData = Array.from(cells).map(cell => cell.textContent).join(",");
        csvContent += `${rowData}\n`;
    });

    // Create a Blob with the CSV content
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

    // Prompt the user to name the file
    const fileName = prompt("Enter a name for the CSV file:", "data_log");

    // Create a link to download the file
    if (fileName) {
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `${fileName}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

async function fetchDeviceWeightAndUnit() {
    // Send 'W' to get the current weight
    await writer.write('W\r');
    let weightResult = '';
    const decoder = new TextDecoder();
    while (true) {
        const { value, done } = await globalReader.read();
        if (done) break;
        weightResult += decoder.decode(value);
        if (weightResult.includes('\n')) break;
    }
    const weight = parseFloat(weightResult.trim());

    // Send 'UNITS' to get the current unit
    await writer.write('UNITS\r');
    let unitResult = '';
    while (true) {
        const { value, done } = await globalReader.read();
        if (done) break;
        unitResult += decoder.decode(value);
        if (unitResult.includes('\n')) break;
    }
    const deviceUnit = unitResult.trim();
    return { weight, deviceUnit };
}

</script>

<script>
    var chart; // Global chart instance
    var chartData = []; // Array to hold the data points
    var chartLabels = []; // Array to hold the labels (timestamps)
    var chartMode = 'cumulative'; // Track the current chart mode

    // Initialize Chart.js chart
    function initializeChart() {
        var ctx = document.getElementById('dataChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line', // Line chart
            data: {
                labels: chartLabels,
                datasets: [{
                    label: 'Sensor Reading',
                    backgroundColor: 'rgba(0, 0, 0, 0)', // Transparent background for the line
                    borderColor: 'rgba(255, 99, 132, 1)',
                    data: chartData,
                    fill: false,
                }]
            },
            options: {
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgba(255, 255, 255, 0.1)' // Lighter grid lines for better visibility
                        },
                        type: 'time',
                        time: {
                            unit: 'second',
                            displayFormats: {
                                second: 'h:mm:ss a'
                            }
                        }
                    }],
                    yAxes: [{
                        gridLines: {
                            color: 'rgba(255, 255, 255, 0.1)' // Lighter grid lines for better visibility
                        }
                    }]
                },
                elements: {
                    line: {
                        tension: 0 // Disable bezier curves for better performance
                    }
                },
                plugins: {
                    decimation: {
                        enabled: true,
                        algorithm: 'min-max', // Choose the decimation algorithm
                        samples: 5000 // Number of samples to keep
                    }
                }
            }
        });
    }

    // Function to show the cumulative graph (default mode)
    function showCumulativeGraph() {
        chartMode = 'cumulative';
        chart.data.labels = chartLabels;
        chart.data.datasets[0].data = chartData;
        chart.update({animation: false}); // Disable animation
    }

    // Function to show only the most recent 5 values
    function showRecentGraph() {
        chartMode = 'recent';
        var recentLabels = chartLabels.slice(-10);  // Get the last 5 labels
        var recentData = chartData.slice(-10);  // Get the last 5 data points
        chart.data.labels = recentLabels;
        chart.data.datasets[0].data = recentData;
        chart.update({animation: false}); // Disable animation
    }

    // Call initializeChart() on document ready
    document.addEventListener('DOMContentLoaded', function() {
        initializeChart();
        createTableHead();
  const tableBody = document.querySelector('#data-table tbody'); // Select the table body
  const table = tableBody.parentElement; // Get the table element
  table.insertBefore(createTableHead(), tableBody); // Insert the table head before the table body
  document.getElementById("graphtype").textContent = chartMode === 'cumulative'? 'Cumulative': 'Strip Chart';
    });
    function removeTableHead() {
    const table = document.querySelector('#data-table');
    const tableHead = table.querySelector('thead');
    if (tableHead) {
      table.removeChild(tableHead);
    }
  }
    function createTableHead() {
  const table = document.querySelector('#data-table');
  // Remove any existing thead
  const oldHead = table.querySelector('thead');
  if (oldHead) {
    table.removeChild(oldHead);
  }
  const tableHead = document.createElement("thead");
  const headerRow = document.createElement("tr");
  const headers = ["Time", "Reading"+` (${_currentUnit})`, "Peak"+` (${_currentUnit})`, "Low"+` (${_currentUnit})`];
  headers.forEach(headerText => {
    const headerCell = document.createElement("th");
    headerCell.textContent = headerText; // Set the header text
    headerCell.style.fontWeight = "normal"; // Set normal font weight
    headerRow.appendChild(headerCell);
  });
  tableHead.appendChild(headerRow);
  table.insertBefore(tableHead, table.querySelector('tbody'));
  return tableHead;
}
</script>

<script>
// Store calibration data for both directions
globalThis.calibrationPointsCompression = [];
globalThis.calibrationPointsTension = [];
const MIN_CALIB_ROWS = 1;
const DEFAULT_CALIB_ROWS = 9;
let ncalMode = 1; // 1 = compression only, 2 = both

function setNCALMode() {
  ncalMode = parseInt(document.getElementById('ncal-mode').value);
  renderCalibrationTable();
}

function renderCalibrationTable() {
  const tbody = document.getElementById('calibration-table-body');
  tbody.innerHTML = '';
  for (let idx = 0; idx < Math.max(calibrationPointsCompression.length, calibrationPointsTension.length); idx++) {
    const tr = document.createElement('tr');
    // Compression Row Number
    const tdCompNum = document.createElement('td');
    tdCompNum.style.textAlign = 'center';
    tdCompNum.textContent = idx + 1;
    tr.appendChild(tdCompNum);
    // Compression Known Load
    const tdCompLoad = document.createElement('td');
    const inputCompLoad = document.createElement('input');
    inputCompLoad.type = 'number';
    inputCompLoad.id = `comp-load-${idx+1}`;
    inputCompLoad.style.width = '80px';
    inputCompLoad.style.height = '22px';
    inputCompLoad.style.fontSize = '14px';
    inputCompLoad.style.textAlign = 'center';
    inputCompLoad.placeholder = 'Enter';
    inputCompLoad.value = calibrationPointsCompression[idx]?.weight ?? '';
    inputCompLoad.onchange = (e) => { calibrationPointsCompression[idx].weight = parseFloat(e.target.value); };
    tdCompLoad.appendChild(inputCompLoad);
    tr.appendChild(tdCompLoad);
    // Compression Raw
    const tdCompRaw = document.createElement('td');
    tdCompRaw.id = `comp-raw-${idx+1}`;
    tdCompRaw.style.textAlign = 'center';
    tdCompRaw.textContent = calibrationPointsCompression[idx]?.raw !== undefined && calibrationPointsCompression[idx]?.raw !== null ? calibrationPointsCompression[idx].raw.toFixed(2) : '---';
    tr.appendChild(tdCompRaw);
    // Compression Read + Add/Remove
    const tdCompRead = document.createElement('td');
    tdCompRead.style.display = 'flex';
    tdCompRead.style.alignItems = 'center';
    const btnCompRead = document.createElement('button');
    btnCompRead.textContent = 'Capture';
    btnCompRead.style.color = 'white';
    btnCompRead.style.width = '60px';
    btnCompRead.style.height = '22px';
    btnCompRead.style.fontSize = '13px';
    btnCompRead.onclick = () => readCalibrationRaw(idx+1, 'compression');
    tdCompRead.appendChild(btnCompRead);
    // Add button (only on last row)
    let btnAdd, btnRemove;
    if (idx === calibrationPointsCompression.length - 1) {
      btnAdd = document.createElement('button');
      btnAdd.textContent = '+';
      btnAdd.title = 'Add row';
      btnAdd.style.color = 'white';
      btnAdd.style.backgroundColor = '#007BC6';
      btnAdd.style.width = '25px';
      btnAdd.style.height = '22px';
      btnAdd.style.fontSize = '13px';
      btnAdd.style.marginLeft = '6px';
      btnAdd.onclick = () => addCalibrationRow('compression');
    }
    if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
      btnRemove = document.createElement('button');
      btnRemove.textContent = '';
      btnRemove.title = 'Remove row';
      btnRemove.style.color = 'white';
      btnRemove.style.backgroundColor = '#d9534f';
      btnRemove.style.width = '28px';
      btnRemove.style.height = '22px';
      btnRemove.style.fontSize = '15px';
      btnRemove.style.marginLeft = '6px';
      btnRemove.onclick = () => removeCalibrationRow(idx);
    }
    // Append in new order: X then +
    if (btnRemove) tdCompRead.appendChild(btnRemove);
    if (btnAdd) tdCompRead.appendChild(btnAdd);
    tr.appendChild(tdCompRead);
    // Tension Row Number
    const tdTenNum = document.createElement('td');
    tdTenNum.style.textAlign = 'center';
    tdTenNum.textContent = idx + 1;
    tr.appendChild(tdTenNum);
    // Tension Known Load
    const tdTenLoad = document.createElement('td');
    const inputTenLoad = document.createElement('input');
    inputTenLoad.type = 'number';
    inputTenLoad.id = `ten-load-${idx+1}`;
    inputTenLoad.style.width = '80px';
    inputTenLoad.style.height = '22px';
    inputTenLoad.style.fontSize = '14px';
    inputTenLoad.style.textAlign = 'center';
    inputTenLoad.placeholder = 'Enter';
    inputTenLoad.value = calibrationPointsTension[idx]?.weight ?? '';
    inputTenLoad.onchange = (e) => { calibrationPointsTension[idx].weight = parseFloat(e.target.value); };
    if (ncalMode === 1) inputTenLoad.disabled = true; inputTenLoad.style.background = '#eee';
    tdTenLoad.appendChild(inputTenLoad);
    tr.appendChild(tdTenLoad);
    // Tension Raw
    const tdTenRaw = document.createElement('td');
    tdTenRaw.id = `ten-raw-${idx+1}`;
    tdTenRaw.style.textAlign = 'center';
    tdTenRaw.textContent = calibrationPointsTension[idx]?.raw !== undefined && calibrationPointsTension[idx]?.raw !== null ? calibrationPointsTension[idx].raw.toFixed(2) : '---';
    if (ncalMode === 1) tdTenRaw.style.background = '#eee';
    tr.appendChild(tdTenRaw);
    // Tension Read + Add/Remove
    const tdTenRead = document.createElement('td');
    tdTenRead.style.display = 'flex';
    tdTenRead.style.alignItems = 'center';
    const btnTenRead = document.createElement('button');
    btnTenRead.textContent = 'Capture';
    btnTenRead.style.color = 'white';
    btnTenRead.style.width = '60px';
    btnTenRead.style.height = '22px';
    btnTenRead.style.fontSize = '13px';
    btnTenRead.onclick = () => readCalibrationRaw(idx+1, 'tension');
    if (ncalMode === 1) {
      btnTenRead.disabled = true;
      btnTenRead.style.background = '#eee';
    } else {
      btnTenRead.style.backgroundColor = '#007BC6'; // Make blue when enabled
    }
    tdTenRead.appendChild(btnTenRead);
    // Add button (only on last row)
    let btnAddTen, btnRemoveTen;
    if (idx === calibrationPointsTension.length - 1) {
      btnAddTen = document.createElement('button');
      btnAddTen.textContent = '+';
      btnAddTen.title = 'Add row';
      btnAddTen.style.color = 'white';
      btnAddTen.style.backgroundColor = '#007BC6';
      btnAddTen.style.width = '25px';
      btnAddTen.style.height = '22px';
      btnAddTen.style.fontSize = '13px';
      btnAddTen.style.marginLeft = '6px';
      btnAddTen.onclick = () => addCalibrationRow('tension');
    }
    if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
      btnRemoveTen = document.createElement('button');
      btnRemoveTen.textContent = '';
      btnRemoveTen.title = 'Remove row';
      btnRemoveTen.style.color = 'white';
      btnRemoveTen.style.backgroundColor = '#d9534f';
      btnRemoveTen.style.width = '28px';
      btnRemoveTen.style.height = '22px';
      btnRemoveTen.style.fontSize = '15px';
      btnRemoveTen.style.marginLeft = '6px';
      btnRemoveTen.onclick = () => removeCalibrationRow(idx);
    }
    // Append in new order: X then +
    if (ncalMode !== 1 && btnRemoveTen) tdTenRead.appendChild(btnRemoveTen);
    if (ncalMode !== 1 && btnAddTen) tdTenRead.appendChild(btnAddTen);
    tr.appendChild(tdTenRead);
    tbody.appendChild(tr);
  }
}
function addCalibrationRow(direction) {
  // Always add a row to both arrays to keep them aligned
  calibrationPointsCompression.push({ weight: null, raw: null });
  calibrationPointsTension.push({ weight: null, raw: null });
  renderCalibrationTable();
}
function removeCalibrationRow(idx) {
  // Only remove if both arrays have more than the minimum rows
  if (calibrationPointsCompression.length > MIN_CALIB_ROWS && calibrationPointsTension.length > MIN_CALIB_ROWS) {
    calibrationPointsCompression.splice(idx, 1);
    calibrationPointsTension.splice(idx, 1);
    renderCalibrationTable();
  }
}
// Initialize calibration points
(function() {
  calibrationPointsCompression = Array(DEFAULT_CALIB_ROWS).fill().map(() => ({ weight: null, raw: null }));
  calibrationPointsTension = Array(DEFAULT_CALIB_ROWS).fill().map(() => ({ weight: null, raw: null }));
  document.addEventListener('DOMContentLoaded', renderCalibrationTable);
})();
// Update readCalibrationRaw to use direction
async function readCalibrationRaw(idx, direction) {
  let weightInput, rawCell, arr;
  if (direction === 'compression') {
    weightInput = document.getElementById(`comp-load-${idx}`);
    rawCell = document.getElementById(`comp-raw-${idx}`);
    arr = calibrationPointsCompression;
  } else {
    weightInput = document.getElementById(`ten-load-${idx}`);
    rawCell = document.getElementById(`ten-raw-${idx}`);
    arr = calibrationPointsTension;
  }
  const weight = parseFloat(weightInput.value);
  if (isNaN(weight)) {
    alert('Please enter a known load before reading.');
    return;
  }
  rawCell.textContent = 'Averaging...';
  const avgRawValue = await getMovingAverageRawValue(50, 20);
  if (isNaN(avgRawValue)) {
    rawCell.textContent = 'Error';
    alert('Failed to get a valid average raw value.');
    return;
  }
  rawCell.textContent = avgRawValue.toFixed(2);
  arr[idx - 1] = { weight, raw: avgRawValue };
}

function calculateCalibration() {
  let points = [];
  if (ncalMode === 1) {
    points = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
  } else {
    // Merge valid points from both arrays
    const comp = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    const ten = calibrationPointsTension.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    points = comp.concat(ten);
  }
  if (points.length < 2) {
    document.getElementById('calibration-result').textContent = 'At least 2 points are required for calibration.';
    return;
  }
  
  // Calculate R for linear fit
  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0, n = points.length;
  for (const pt of points) {
    sumX += pt.weight;
    sumY += pt.raw;
    sumXY += pt.weight * pt.raw;
    sumXX += pt.weight * pt.weight;
    sumYY += pt.raw * pt.raw;
  }
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  // Calculate R for linear fit
  const meanY = sumY / n;
  let ssRes = 0, ssTot = 0;
  for (const pt of points) {
    const predicted = slope * pt.weight + intercept;
    ssRes += Math.pow(pt.raw - predicted, 2);
    ssTot += Math.pow(pt.raw - meanY, 2);
  }
  const rSquaredLinear = 1 - (ssRes / ssTot);
  
  let resultText = `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>`;
  resultText += `R = ${rSquaredLinear.toFixed(4)}<br>`;
  
  // Store for burning
  window._calibSlope = slope;
  window._calibIntercept = intercept;
  
  // If at least 4 points, also show cubic fit
  if (points.length >= 4) {
    const x = points.map(pt => pt.weight);
    const y = points.map(pt => pt.raw);
    
    function cubicFit(x, y) {
      const n = x.length;
      let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumX5 = 0, sumX6 = 0;
      let sumY = 0, sumXY = 0, sumX2Y = 0, sumX3Y = 0;
      for (let i = 0; i < n; i++) {
        const xi = x[i], yi = y[i];
        const xi2 = xi * xi, xi3 = xi2 * xi, xi4 = xi3 * xi, xi5 = xi4 * xi, xi6 = xi5 * xi;
        sumX += xi;
        sumX2 += xi2;
        sumX3 += xi3;
        sumX4 += xi4;
        sumX5 += xi5;
        sumX6 += xi6;
        sumY += yi;
        sumXY += xi * yi;
        sumX2Y += xi2 * yi;
        sumX3Y += xi3 * yi;
      }
      const A = [
        [sumX6, sumX5, sumX4, sumX3],
        [sumX5, sumX4, sumX3, sumX2],
        [sumX4, sumX3, sumX2, sumX],
        [sumX3, sumX2, sumX, n]
      ];
      const B = [sumX3Y, sumX2Y, sumXY, sumY];
      function gauss(A, B) {
        const n = B.length;
        for (let i = 0; i < n; i++) {
          let maxRow = i;
          for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
          }
          [A[i], A[maxRow]] = [A[maxRow], A[i]];
          [B[i], B[maxRow]] = [B[maxRow], B[i]];
          for (let k = i + 1; k < n; k++) {
            const c = A[k][i] / A[i][i];
            for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
            B[k] -= c * B[i];
          }
        }
        const x = Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
          x[i] = B[i];
          for (let j = i + 1; j < n; j++) x[i] -= A[i][j] * x[j];
          x[i] /= A[i][i];
        }
        return x;
      }
      return gauss(A, B); // [a, b, c, d]
    }
    
    const [CCA, CCB, CCC, CCD] = cubicFit(x, y);
    
    // Calculate R for cubic fit
    let ssResCubic = 0;
    for (const pt of points) {
      const predicted = CCA * Math.pow(pt.weight, 3) + CCB * Math.pow(pt.weight, 2) + CCC * pt.weight + CCD;
      ssResCubic += Math.pow(pt.raw - predicted, 2);
    }
    const rSquaredCubic = 1 - (ssResCubic / ssTot);
    
    resultText += `<br>Cubic fit: raw = (${CCA.toExponential(6)})*weight^3 + (${CCB.toExponential(6)})*weight^2 + (${CCC.toExponential(6)})*weight + (${CCD.toExponential(6)})<br>`;
    resultText += `R = ${rSquaredCubic.toFixed(4)}<br>`;
  }
  
  // Show which points were used
  if (ncalMode === 1) {
    resultText += '<br><em>Used only compression points.</em>';
  } else {
    resultText += '<br><em>Used both compression and tension points.</em>';
  }
  document.getElementById('calibration-result').innerHTML = resultText;
}

async function burnCalibration() {
  let validPoints = [];
  if (ncalMode === 1) {
    validPoints = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
  } else {
    const comp = calibrationPointsCompression.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    const ten = calibrationPointsTension.filter(pt => pt.weight !== null && pt.raw !== null && !isNaN(pt.weight) && !isNaN(pt.raw));
    validPoints = comp.concat(ten);
  }
  if (validPoints.length < 4) {
    alert('At least 4 calibration points are required for cubic calibration.');
    return;
  }
  // Prepare arrays for cubic fit
  const x = validPoints.map(pt => pt.weight);
  const y = validPoints.map(pt => pt.raw);
  // Cubic fit using least squares (returns [a, b, c, d] for ax^3 + bx^2 + cx + d)
  function cubicFit(x, y) {
    const n = x.length;
    let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumX5 = 0, sumX6 = 0;
    let sumY = 0, sumXY = 0, sumX2Y = 0, sumX3Y = 0;
    for (let i = 0; i < n; i++) {
      const xi = x[i], yi = y[i];
      const xi2 = xi * xi, xi3 = xi2 * xi, xi4 = xi3 * xi, xi5 = xi4 * xi, xi6 = xi5 * xi;
      sumX += xi;
      sumX2 += xi2;
      sumX3 += xi3;
      sumX4 += xi4;
      sumX5 += xi5;
      sumX6 += xi6;
      sumY += yi;
      sumXY += xi * yi;
      sumX2Y += xi2 * yi;
      sumX3Y += xi3 * yi;
    }
    // Solve the normal equations for cubic fit
    const A = [
      [sumX6, sumX5, sumX4, sumX3],
      [sumX5, sumX4, sumX3, sumX2],
      [sumX4, sumX3, sumX2, sumX],
      [sumX3, sumX2, sumX, n]
    ];
    const B = [sumX3Y, sumX2Y, sumXY, sumY];
    // Gaussian elimination
    function gauss(A, B) {
      const n = B.length;
      for (let i = 0; i < n; i++) {
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
        }
        [A[i], A[maxRow]] = [A[maxRow], A[i]];
        [B[i], B[maxRow]] = [B[maxRow], B[i]];
        for (let k = i + 1; k < n; k++) {
          const c = A[k][i] / A[i][i];
          for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
          B[k] -= c * B[i];
        }
      }
      const x = Array(n).fill(0);
      for (let i = n - 1; i >= 0; i--) {
        x[i] = B[i];
        for (let j = i + 1; j < n; j++) x[i] -= A[i][j] * x[j];
        x[i] /= A[i][i];
      }
      return x;
    }
    return gauss(A, B); // [a, b, c, d]
  }
  // Fit cubic: raw = a*x^3 + b*x^2 + c*x + d
  const [CCA, CCB, CCC, CCD] = cubicFit(x, y);
  // Use the first raw value as FAZ (offset)
  const FAZ = validPoints[0].raw;
  // Show the cubic fit equation and coefficients
  document.getElementById('calibration-result').textContent =
    `Cubic fit: raw = (${CCA.toExponential(6)})*weight^3 + (${CCB.toExponential(6)})*weight^2 + (${CCC.toExponential(6)})*weight + (${CCD.toExponential(6)})\nFAZ = ${FAZ}` + (ncalMode === 2 ? '\n(Used both compression and tension points)' : '\n(Used only compression points)');
  // Send the coefficients to the sensor for universal calibration
  try {
    await writer.write(`ncal ${ncalMode}\r`); // Set NCAL mode
    await delay(500);
    await writer.write(`CCA ${CCA}\r`);
    await delay(500);
    await writer.write(`CCB ${CCB}\r`);
    await delay(500);
    await writer.write(`CCC ${CCC}\r`);
    await delay(500);
    await writer.write(`CCD ${CCD}\r`);
    await delay(500);
    await writer.write(`FAZ ${FAZ}\r`);
    await delay(500);
    alert('Cubic (curve fit) calibration burned successfully!');
  } catch (e) {
    alert('Failed to burn cubic calibration: ' + e);
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Helper function to get moving average of N raw sensor values
async function getMovingAverageRawValue(numReadings = 50, delayMs = 20) {
  const readings = [];
  for (let i = 0; i < numReadings; i++) {
    const rawValue = await fetchRawSensorValue();
    const parsed = parseFloat(rawValue);
    if (!isNaN(parsed)) readings.push(parsed);
    await delay(delayMs); // Small delay to avoid overwhelming the sensor
  }
  // Calculate average
  const sum = readings.reduce((a, b) => a + b, 0);
  return (readings.length > 0) ? (sum / readings.length) : NaN;
}

// Restore fetchRawSensorValue globally
async function fetchRawSensorValue() {
  // Sends 'R\r' to get the raw ADC value from the sensor
  const command = 'R\r';
  try {
    await writer.write(command);
    const decoder = new TextDecoder();
    let result = '';
    while (true) {
      const { value, done } = await globalReader.read();
      if (done) break;
      result += decoder.decode(value);
      if (result.includes('\n')) break;
    }
    // Extract the first number from the result
    const match = result.match(/-?\d+(?:\.\d+)?/);
    return match ? match[0] : result.trim();
  } catch (error) {
    console.error('Error reading raw ADC value:', error);
    return 'Error';
  }
}

function openCalibrationModal() {
  document.getElementById('calibration-modal').style.display = 'flex';
}
function closeCalibrationModal() {
  document.getElementById('calibration-modal').style.display = 'none';
}

async function burnID() {
    const newID = document.getElementById("sensorID").value;
    if (!newID) { alert("ID cannot be empty"); return; }
    try {
        await writer.write(`ss1 ${newID}\r`);
        alert("ID burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn ID: " + e);
    }
}
async function burnCapacity() {
    const newCap = document.getElementById("sensorCapacity").value;
    if (!newCap) { alert("Capacity cannot be empty"); return; }
    try {
        await writer.write(`slc ${newCap}\r`);
        alert("Capacity burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn Capacity: " + e);
    }
}
async function burnUnits() {
    const newUnits = document.getElementById("sensorUnits").value;
    if (!newUnits) { alert("Units cannot be empty"); return; }
    try {
        await writer.write(`unit ${newUnits}\r`);
        alert("Units burned to sensor successfully!");
    } catch (e) {
        alert("Failed to burn Units: " + e);
    }
}
// Calibration live raw value/plot state
let calibPlotRunning = false; // Start paused by default
let calibRawHistory = [];
const CALIB_RAW_HISTORY_MAX = 100;
let calibRawPlot = null;
let calibRawInterval = null;

// Add global state for polling control
let pollingMode = 'main'; // 'main' or 'calibration'

// Patch calibration plot controls to pause/resume main display polling
function stopMainDisplayPolling() {
  if (readingInterval) {
    clearInterval(readingInterval);
    readingInterval = null;
    document.getElementById("stop").style.display = "none";
    document.getElementById("read").style.display = "block";
  }
  isStart = false;
}
function allowMainDisplayPolling() {
  // No-op: showReading can be called by user
}
// Patch calibration plot toggle
function stopCalibRawPlot() {
  calibPlotRunning = false;
  document.getElementById('calib-plot-toggle').textContent = 'Start';
  pollingMode = 'main';
  allowMainDisplayPolling();
}
function resumeCalibRawPlot() {
  calibPlotRunning = true;
  document.getElementById('calib-plot-toggle').textContent = 'Stop';
  pollingMode = 'calibration';
  stopMainDisplayPolling();
}
// Patch calibration plot startup
function startCalibRawPlot() {
  if (calibRawInterval) clearInterval(calibRawInterval);
  calibPlotRunning = true;
  pollingMode = 'calibration';
  stopMainDisplayPolling();
  document.getElementById('calib-plot-toggle').textContent = 'Stop';
  calibRawInterval = setInterval(async () => {
    if (!calibPlotRunning) return;
    // Only fetch if main display is not polling
    if (pollingMode !== 'calibration') return;
    const rawVal = await fetchRawSensorValue();
    const parsed = parseFloat(rawVal);
    if (!isNaN(parsed)) {
      calibRawHistory.push(parsed);
      if (calibRawHistory.length > CALIB_RAW_HISTORY_MAX) calibRawHistory.shift();
      document.getElementById('calib-current-raw').textContent = parsed.toFixed(2);
      updateCalibRawPlot();
    }
  }, 200);
}
function updateCalibRawPlot() {
  if (!calibRawPlot) return;
  calibRawPlot.data.labels = calibRawHistory.map((_, i) => i);
  calibRawPlot.data.datasets[0].data = calibRawHistory;
  calibRawPlot.update();
}
function setupCalibRawPlot() {
  const ctx = document.getElementById('calib-raw-plot').getContext('2d');
  calibRawPlot = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Raw',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#FF6384', // Use the same color as the heading
        data: [],
        fill: false,
        pointRadius: 0,
        borderWidth: 2,
      }]
    },
    options: {
      animation: false,
      responsive: false,
      legend: {
        display: true,
        labels: {
          usePointStyle: true,
          boxWidth: 0,
          fontColor: '#fff',
          padding: 12,
          generateLabels: function(chart) {
            // Only show text, no box
            return [{
              text: 'Raw',
              fillStyle: 'rgba(0,0,0,0)',
              strokeStyle: 'rgba(0,0,0,0)',
              lineWidth: 0,
              hidden: false,
              index: 0
            }];
          }
        }
      },
      scales: {
        xAxes: [{ display: false }],
        yAxes: [{ display: true, ticks: { fontSize: 10, fontColor: '#fff' }, gridLines: { color: 'rgba(255,255,255,0.1)' } }]
      },
      elements: { line: { tension: 0 } }
    }
  });
}
document.addEventListener('DOMContentLoaded', function() {
  setupCalibRawPlot();
  // Do NOT startCalibRawPlot() by default
  document.getElementById('calib-plot-toggle').onclick = function() {
    if (calibPlotRunning) stopCalibRawPlot();
    else startCalibRawPlot(); // Only start polling when user presses Resume
  };
  // Set button to Resume by default
  document.getElementById('calib-plot-toggle').textContent = 'Start';
  // Add Clear button handler
  document.getElementById('calib-plot-clear').onclick = function() {
    calibRawHistory = [];
    if (calibRawPlot) {
      calibRawPlot.data.labels = [];
      calibRawPlot.data.datasets[0].data = [];
      calibRawPlot.update();
    }
    document.getElementById('calib-current-raw').textContent = '---';
  };
});
// Patch readCalibrationRaw to pause/resume plot
const origReadCalibrationRaw = readCalibrationRaw;
readCalibrationRaw = async function(idx, direction) {
  stopCalibRawPlot();
  await origReadCalibrationRaw(idx, direction);
  // After reading, allow user to resume
  setTimeout(() => {
    resumeCalibRawPlot();
  }, 500); // Small delay to avoid overlap
};
</script>

<script>
// Tab switching logic for Calibration Utility
(function() {
  function showTab(tab) {
    document.querySelectorAll('.calib-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById('calib-tab-content-' + tab).style.display = 'block';
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.classList.remove('active-tab');
    });
    document.querySelector('.calib-tab-btn[data-tab="' + tab + '"]').classList.add('active-tab');
    // If switching to verify, (re)initialize chart if needed
    if(tab === 'verify') {
      if(window.chart && window.chart.data) {
        window.chart.update();
      } else if(typeof initializeChart === 'function') {
        initializeChart();
      }
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
      document.getElementById("graphtype").textContent = window.chartMode === 'cumulative'? 'Cumulative': 'Strip Chart';
    }
    // If switching to data, ensure table head is present
    if(tab === 'data') {
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
    }
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.onclick = function() { showTab(btn.getAttribute('data-tab')); };
    });
    showTab('specs'); // Default tab
  });
})();
// 2-Point Calibration logic (stub, to be implemented)
window.read2ptRaw = async function(idx) {
  const input = document.getElementById('twopt-load' + idx);
  const rawCell = document.getElementById('twopt-raw' + idx);
  const weight = parseFloat(input.value);
  if (isNaN(weight)) { alert('Please enter a known load before reading.'); return; }
  
  // Pause calibration plot if running
  const wasPlotRunning = calibPlotRunning;
  if (wasPlotRunning) {
    stopCalibRawPlot();
  }
  
  rawCell.textContent = 'Averaging...';
  const avgRawValue = await getMovingAverageRawValue(50, 20);
  if (isNaN(avgRawValue)) {
    rawCell.textContent = 'Error';
    alert('Failed to get a valid average raw value.');
    return;
  }
  rawCell.textContent = avgRawValue.toFixed(2);
  input.setAttribute('data-raw', avgRawValue);
  
  // Resume plot if it was running before
  if (wasPlotRunning) {
    setTimeout(() => {
      resumeCalibRawPlot();
    }, 500);
  }
};
window.calculate2ptCalibration = function() {
  const w1 = parseFloat(document.getElementById('twopt-load1').value);
  const w2 = parseFloat(document.getElementById('twopt-load2').value);
  const r1 = parseFloat(document.getElementById('twopt-raw1').textContent);
  const r2 = parseFloat(document.getElementById('twopt-raw2').textContent);
  
  if ([w1, w2, r1, r2].some(x => isNaN(x))) {
    document.getElementById('calibration-result-2pt').textContent = 'Please enter both weights and read both raw values.';
    return;
  }
  
  // Check that the two points are different
  if (w1 === w2) {
    document.getElementById('calibration-result-2pt').textContent = 'Error: The two known loads must be different for 2-point calibration.';
    return;
  }
  
  // Linear fit: raw = slope * weight + intercept
  const slope = (r2 - r1) / (w2 - w1);
  const intercept = r1 - slope * w1;
  
  // Calculate R for 2-point linear fit
  const points = [{weight: w1, raw: r1}, {weight: w2, raw: r2}];
  const meanY = (r1 + r2) / 2;
  let ssRes = 0, ssTot = 0;
  for (const pt of points) {
    const predicted = slope * pt.weight + intercept;
    ssRes += Math.pow(pt.raw - predicted, 2);
    ssTot += Math.pow(pt.raw - meanY, 2);
  }
  const rSquared = 1 - (ssRes / ssTot);
  
  // Store for use in main display and burning
  window._calibSlope = slope;
  window._calibIntercept = intercept;
  
  document.getElementById('calibration-result-2pt').innerHTML = 
    `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>` +
    `R = ${rSquared.toFixed(4)}<br>` +
    `Calibration ready to burn.`;
};
window.burn2ptCalibration = async function() {
  const w1 = parseFloat(document.getElementById('twopt-load1').value);
  const w2 = parseFloat(document.getElementById('twopt-load2').value);
  const r1 = parseFloat(document.getElementById('twopt-raw1').textContent);
  const r2 = parseFloat(document.getElementById('twopt-raw2').textContent);
  
  if ([w1, w2, r1, r2].some(x => isNaN(x))) {
    alert('Please enter both weights and read both raw values before burning calibration.');
    return;
  }
  
  // Check that the two points are different
  if (w1 === w2) {
    alert('Error: The two known loads must be different for 2-point calibration.');
    return;
  }
  
  // Calculate linear fit: raw = slope * weight + intercept
  const slope = (r2 - r1) / (w2 - w1);
  const intercept = r1 - slope * w1;
  
  // For 2-point calibration, we use linear fit (cubic with a=b=0)
  const CCA = 0; // No cubic term
  const CCB = 0; // No quadratic term  
  const CCC = slope; // Linear coefficient
  const CCD = intercept; // Constant term
  const FAZ = r1; // Use first raw value as offset
  
  try {
    // Set NCAL mode to 1 (single direction/compression only for 2-point)
    await writer.write(`ncal 1\r`);
    await delay(500);
    
    // Send the coefficients to the sensor
    await writer.write(`CCA ${CCA}\r`);
    await delay(500);
    await writer.write(`CCB ${CCB}\r`);
    await delay(500);
    await writer.write(`CCC ${CCC}\r`);
    await delay(500);
    await writer.write(`CCD ${CCD}\r`);
    await delay(500);
    await writer.write(`FAZ ${FAZ}\r`);
    await delay(500);
    
    // Update the result display
    document.getElementById('calibration-result-2pt').innerHTML = 
      `2-Point Linear Calibration burned successfully!<br>` +
      `Linear fit: raw = ${slope.toFixed(6)} * weight + ${intercept.toFixed(2)}<br>` +
      `FAZ = ${FAZ.toFixed(2)}`;
    
    // Store for use in main display
    window._calibSlope = slope;
    window._calibIntercept = intercept;
    
    alert('2-Point calibration burned successfully!');
  } catch (e) {
    alert('Failed to burn 2-point calibration: ' + e);
  }
};
</script>

<script>
async function burnMVV() {
    const mvvValue = document.getElementById("mvv-value").value;
    const resultDiv = document.getElementById("mvv-burn-result");
    if (!mvvValue || isNaN(mvvValue) || parseFloat(mvvValue) <= 0) {
        resultDiv.textContent = "Please enter a valid mV/V value.";
        resultDiv.style.color = "#d9534f";
        return;
    }
    try {
        await writer.write(`mvv ${mvvValue}\r`);
        resultDiv.textContent = `mV/V value ${mvvValue} burned to sensor successfully!`;
        resultDiv.style.color = "#007BC6";
    } catch (e) {
        resultDiv.textContent = "Failed to burn mV/V value: " + e;
        resultDiv.style.color = "#d9534f";
    }
}

(function() {
  function showTab(tab) {
    document.querySelectorAll('.calib-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById('calib-tab-content-' + tab).style.display = 'block';
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.classList.remove('active-tab');
    });
    document.querySelector('.calib-tab-btn[data-tab="' + tab + '"]').classList.add('active-tab');
    // If switching to verify, (re)initialize chart if needed and start calibration monitoring
    if(tab === 'verify') {
      if(window.chart && window.chart.data) {
        window.chart.update();
      } else if(typeof initializeChart === 'function') {
        initializeChart();
      }
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
      document.getElementById("graphtype").textContent = window.chartMode === 'cumulative'? 'Cumulative': 'Strip Chart';
      // Start calibration monitoring if connected
      if (port && writer && globalReader) {
        startCalibrationMonitoring();
      }
    }
    // If switching to data, ensure table head is present
    if(tab === 'data') {
      if(typeof createTableHead === 'function') {
        createTableHead();
        const tableBody = document.querySelector('#data-table tbody');
        const table = tableBody.parentElement;
        table.insertBefore(createTableHead(), tableBody);
      }
    }
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.calib-tab-btn').forEach(btn => {
      btn.onclick = function() { showTab(btn.getAttribute('data-tab')); };
    });
    showTab('specs'); // Default tab
  });
})();

// Add event listener for manual refresh button
document.addEventListener('DOMContentLoaded', function() {
  var refreshBtn = document.getElementById('refresh-calib-status-btn');
  if (refreshBtn) {
    refreshBtn.onclick = function() {
      startCalibrationMonitoring();
    };
  }
});
</script>
</body>
</html>